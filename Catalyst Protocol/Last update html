<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catalyst Protocol — DApp (Production-ready UI)</title>
	  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="description" content="Catalyst Protocol dApp — staking, governance, council" />
	<link rel="icon" type="image/png" href="assets/logo.png">	
  <style>
    body { background: linear-gradient(180deg,#041024 0%, #061426 100%); }
    .glass { background: rgba(255,255,255,0.03); backdrop-filter: blur(6px); }
	  .tabbtn {transition: all 0.2s ease-in-out;}
.tabbtn:hover {opacity: 0.85; transform: translateY(-1px);}
.tab-active {outline: 2px solid white; outline-offset: 2px;}

  /* Center it on the screen */
  #loadingIndicator {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 9999;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* Spinner circle */
  .spinner {
    border: 6px solid rgba(255, 255, 255, 0.2);
    border-top: 6px solid yellow;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
  }

  /* Spinning animation */
  @keyframes spin {
    0%   { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .loading-text {
    margin-top: 10px;
    color: yellow;
    font-weight: bold;
    font-size: 14px;
  }
  </style>
</head>
<body class="min-h-screen text-white font-sans">
  <div class="max-w-6xl mx-auto p-6">
    <header class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-2xl font-bold">Catalyst Protocol</h1>
        <p class="text-sm text-slate-300">Staking · Governance · Guardian Council</p>
      </div>
      <div class="flex items-center gap-2 text-sm">
  <!-- Connected Card -->
  <div class="px-2 py-1 rounded-lg bg-slate-800/70 shadow border border-slate-700">
    <div class="text-slate-400 text-[10px]">Connected</div>
    <div class="flex items-center gap-1">
      <!-- Shortened address -->
      <span id="addr" 
            class="font-medium text-slate-100 cursor-pointer text-xs"
            title="Not connected">
        Not connected
      </span>
      <!-- Copy button -->
      <button id="copyAddrBtn" 
              class="px-1 py-0.5 text-[10px] bg-slate-700 hover:bg-slate-600 rounded">
        📋
      </button>
    </div>
  </div>
  <!-- Network Card -->
  <div class="px-2 py-1 rounded-lg bg-slate-800/70 shadow border border-slate-700">
    <div class="text-slate-400 text-[10px]">Network</div>
    <div id="networkText" class="font-medium text-slate-100 text-xs">—</div>
  </div>
</div>  
          <!-- Action Buttons -->
  <div class="flex gap-2 mb-4">
    <button id="connectBtn" class="px-4 py-2 rounded-lg bg-gradient-to-r from-green-500 to-cyan-400 font-semibold text-black">
      🔌 Connect Wallet
    </button>
    <button id="disconnectBtn" class="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-500 font-semibold text-black hidden">
      ❌ Disconnect
    </button>
  </div>
      </div>
    </header>
	
    <main class="max-w-7xl mx-auto px-4 py-6 space-y-6">
		

<!-- Tab Buttons -->
<div class="glass ring-1 rounded-2xl p-4 flex flex-wrap gap-3 justify-center">
  <button data-tab="overview" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-sky-700 text-white hover:bg-sky-600 transition tab-active">
    📖 Overview
  </button>

  <button data-tab="quickstatus" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-slate-700 text-white hover:bg-slate-600 transition">
    🧭 Quick Status
  </button>

  <button data-tab="registration" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-indigo-700 text-white hover:bg-indigo-600 transition">
    📝 Collection Registration
  </button>

  <button data-tab="bluechip" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-amber-600 text-black hover:bg-amber-500 transition">
    💎 Bluechip
  </button>

  <button data-tab="staking" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-emerald-700 text-white hover:bg-emerald-600 transition">
    📦 Staking
  </button>

  <button data-tab="governance" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-violet-700 text-white hover:bg-violet-600 transition">
    🏛️ Governance DAO
  </button>

  <button data-tab="council" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-rose-700 text-white hover:bg-rose-600 transition">
    🛡️ DRS Guardian Council
  </button>

  <button data-tab="whitepaper" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-teal-700 text-white hover:bg-teal-600 transition">
    📜 Whitepaper
  </button>
</div>

  <!-- Tab Contents -->
  <div id="tabContents" class="glass rounded-2xl p-4">

	   <!-- Loading Indicator -->
<div id="loadingIndicator" style="display:none;">
  <div class="spinner"></div>
  <div class="loading-text">Loading...</div>
</div> 

<section>
  <div id="overview" class="tab-content">
    <div class="glass ring-1 rounded-2xl p-5 space-y-6">
      <!-- Header -->
      <div class="flex items-start gap-4">
        <div class="w-14 h-14 rounded-xl bg-slate-800 border border-slate-700 grid place-items-center text-2xl">
          🧭
        </div>
        <div class="space-y-2">
          <h2 class="text-xl font-semibold">Catalyst at a Glance</h2>
          <p class="text-slate-300 leading-relaxed">
            Catalyst is a modular NFT staking &amp; governance protocol. Stake ERC-721s for CATA rewards, 
            participate in burn-weighted governance, and rely on the Batch Guardian Council recovery system. 
            The design enforces 
            <span class="chip">security</span>, <span class="chip">scalability</span>, and 
            <span class="chip">sustainability</span> through immutable economics and DAO-managed upgrades.
          </p>
        </div>
      </div>

      <!-- Info Cards -->
      <div class="grid md:grid-cols-3 gap-4">
        <!-- Mission -->
<div class="glass ring-1 rounded-xl p-4">
  <div class="text-sm text-slate-400 mb-1">Mission</div>
  <div class="font-semibold">Non-Profit R&amp;D Utility</div>
  <p class="text-slate-300 text-sm mt-2">
    Immutable fee split 
    <span class="mono">90% Burn / 9% Treasury / 1% Deployer</span>. 
    Catalyst itself is not profit-seeking — fees are burned or directed to a 
    community-governed treasury that funds audits, grants, and continued research &amp; development.
  </p>
  <p class="text-slate-400 text-xs mt-2 leading-relaxed">
    This does not prevent participants from creating value: token holders benefit from deflationary supply, 
    builders can launch services on top of Catalyst, and communities gain legitimacy and rewards. 
    In short, Catalyst is a public-good protocol while its ecosystem can still generate profit and long-term value.
  </p>
</div>

        <!-- Usage -->
        <div class="card rounded-xl p-4 ring-1 glass">
          <div class="text-sm muted mb-2 flex items-center gap-2">
            <span class="badge">Usage</span>
            <span>How to use Catalyst</span>
          </div>
          <ol class="text-sm list-decimal ml-5 space-y-2 text-slate-300 leading-relaxed">
            <li>Locate and save your <span class="font-mono">proxy contract</span> address.</li>
            <li>Connect your wallet to enable <span class="chip">staking</span> and <span class="chip">governance</span> actions.</li>
            <li>Use the tabs to stake NFTs, submit votes, claim rewards, and interact with the Batch Guardian Council.</li>
          </ol>
        </div>

        <!-- Docs -->
        <div class="glass ring-1 rounded-xl p-4">
          <div class="text-sm text-slate-400 mb-1">Docs</div>
          <div class="space-y-1 text-sm text-slate-300">
            <div>
              <span class="badge">See the</span> 
              Whitepaper
              <a href="javascript:void(0)" 
                 class="text-sky-400 hover:text-sky-300 underline cursor-pointer"
                 onclick="selectTab('whitepaper')">
                 summary
              </a>
            </div>
            <div>
              <span class="badge">Review the</span>
              Technical Appendix
              <a href="javascript:void(0)" 
                 class="text-sky-400 hover:text-sky-300 underline cursor-pointer"
                 onclick="selectTab('appendix')">
                 details
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
	  
    <!-- Quick Status -->
<section id="quickstatus" class="tab-content hidden">
  <h2 class="font-semibold mb-3 text-lg text-slate-100">⚡ Quick Status</h2>
<div class="grid grid-cols-2 gap-3 text-sm">
  <!-- Card -->
  <div class="p-3 rounded-xl bg-slate-800/50 shadow-sm border border-slate-700">
    <div class="text-slate-400 text-xs">CATA Balance</div>
    <div id="cataBal" class="font-semibold text-green-400">—</div>
  </div>

  <!-- Card -->
  <div class="p-3 rounded-xl bg-slate-800/50 shadow-sm border border-slate-700">
    <div class="text-slate-400 text-xs">Staked NFTs</div>
    <div id="globalStaked" class="font-semibold text-indigo-400">—</div>
  </div>

  <!-- Card (full width) -->
  <div class="col-span-2 p-3 rounded-xl bg-slate-800/50 shadow-sm border border-slate-700">
    <div class="text-slate-400 text-xs">Roles (CATA / Staking)</div>
    <div id="roles" class="font-semibold text-slate-200">—</div>
  </div>
</div>

  <hr class="my-3 border-slate-700" />
<div class="glass rounded-xl border border-slate-700 shadow-lg p-4 space-y-4">
  <!-- Header -->
  <div class="flex items-center justify-between">
    <h2 class="text-sm font-semibold text-slate-200">Contract Addresses</h2>
    <span class="text-[11px] text-slate-400">Defaults & LocalStorage</span>
  </div>

  <!-- Address Fields -->
  <div class="space-y-3">
    <div>
      <label class="block text-xs text-slate-400 mb-1">CATA Token</label>
      <input id="addrCata" readonly 
             class="w-full px-3 py-2 rounded-lg bg-black/30 border border-slate-700/50 
                    text-sm text-slate-200 focus:outline-none cursor-default" />
    </div>

    <div>
      <label class="block text-xs text-slate-400 mb-1">Staking Contract</label>
      <input id="addrStaking" readonly 
             class="w-full px-3 py-2 rounded-lg bg-black/30 border border-slate-700/50 
                    text-sm text-slate-200 focus:outline-none cursor-default" />
    </div>

    <div>
      <label class="block text-xs text-slate-400 mb-1">Governance Contract</label>
      <input id="addrGovernance" readonly 
             class="w-full px-3 py-2 rounded-lg bg-black/30 border border-slate-700/50 
                    text-sm text-slate-200 focus:outline-none cursor-default" />
    </div>

    <div>
      <label class="block text-xs text-slate-400 mb-1">Guardian Council</label>
      <input id="addrCouncil" readonly 
             class="w-full px-3 py-2 rounded-lg bg-black/30 border border-slate-700/50 
                    text-sm text-slate-200 focus:outline-none cursor-default" />
    </div>
  </div>

  <!-- Actions -->
  <div class="flex gap-3 pt-2">
    <button id="saveAddrs" 
            class="flex-1 px-4 py-2 bg-indigo-600 hover:bg-indigo-500 active:bg-indigo-700 
                   text-white font-medium rounded-lg shadow transition-all text-sm flex items-center gap-1">
      💾 Save
    </button>

    <button id="loadAddrs" 
            class="flex-1 px-4 py-2 bg-slate-700/70 hover:bg-slate-600 active:bg-slate-800 
                   text-slate-100 font-medium rounded-lg shadow transition-all text-sm flex items-center gap-1">
      📂 Load
    </button>
  </div>
</div>


  <hr class="my-3 border-slate-700" />

	<div class="p-4 rounded-xl bg-slate-800 text-slate-200 space-y-4">
  <div class="text-lg font-bold text-slate-100">⚡ CATA Actions</div>

  <!-- Burn -->
  <div>
    <input id="cataBurnAmt" placeholder="Amount to burn" class="w-full p-2 rounded bg-black/20 text-sm" />
    <button id="cataBurnBtn" class="mt-2 w-full p-2 bg-red-600 hover:bg-red-500 rounded">
      🔥 Burn My CATA
    </button>
  </div>

  <!-- Admin-only: Pause/Unpause -->
  <div class="pt-4 border-t border-slate-700">
    <div class="text-xs text-slate-400 mb-1">Admin Controls</div>
    <div class="flex gap-2">
      <button id="pauseBtn" class="flex-1 p-2 bg-yellow-600 hover:bg-yellow-500 rounded">
        ⏸ Pause
      </button>
      <button id="unpauseBtn" class="flex-1 p-2 bg-green-600 hover:bg-green-500 rounded">
        ▶️ Unpause
      </button>
    </div>
  </div>

  <!-- Council-only: Swap Admin -->
  <div class="pt-4 border-t border-slate-700">
    <div class="text-xs text-slate-400 mb-1">Council Actions</div>
    <div class="flex gap-2">
      <input id="swapNewAdmin" placeholder="New admin address" class="flex-1 p-2 rounded bg-black/20 text-sm" />
      <input id="swapOldAdmin" placeholder="Old admin address (optional)" class="flex-1 p-2 rounded bg-black/20 text-sm" />
    </div>
    <button id="swapAdminBtn" class="mt-2 w-full p-2 bg-yellow-500 text-black rounded">
      🔑 Swap Admin
    </button>
  </div>

  <!-- Transparency -->
  <div class="pt-4 border-t border-slate-700">
    <div class="text-xs text-slate-400 mb-1">Transparency</div>
    <div class="flex flex-col gap-1">
      <div class="p-2 rounded bg-black/20 text-sm">
        Remaining Mintable: <span id="cataRemainingMintable" class="font-mono text-green-400">…</span>
      </div>
      <div class="p-2 rounded bg-black/20 text-sm">
        Total Supply: <span id="cataTotalSupply" class="font-mono text-blue-400">…</span>
      </div>
      <div class="p-2 rounded bg-black/20 text-sm">
        Max Supply: <span id="cataMaxSupply" class="font-mono text-yellow-400">…</span>
      </div>
    </div>
    <button id="refreshTransparencyBtn" class="mt-2 w-full p-2 bg-indigo-600 hover:bg-indigo-500 rounded">
      🔍 Refresh Transparency
    </button>
  </div>
</div>
</section>

    <!-- Collection Registration -->
    <section id="registration" class="tab-content hidden">
      <h3 class="font-semibold mb-2">Collection Registration</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mb-2">
        <input id="regCollectionAddr" placeholder="Collection address (ERC721)" class="p-2 rounded bg-black/20 text-sm" />
		  <div id="regStatusInfo" class="text-xs text-slate-400 mt-1">Status: —</div>
        <input id="regDeclaredSupply" placeholder="Declared max supply (integer >=1)" class="p-2 rounded bg-black/20 text-sm" />
      </div>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
        <select id="regTier" class="p-2 rounded bg-black/20 text-sm">
          <option value="0">UNVERIFIED (0)</option>
          <option value="1">VERIFIED (1)</option>
          <option value="2">BLUECHIP (2)</option>
        </select>
        <button id="calcRegFeeBtn" class="p-2 bg-slate-600 rounded text-sm">Calculate Fee</button>
        <div id="regFeeInfo" class="p-2 text-xs text-slate-300">Fee: —</div>
      </div>
      <div class="flex gap-2 mt-2">
        <button id="approveRegCataBtn" class="flex-1 p-2 bg-amber-600 rounded text-sm">Approve CATA for registration</button>
        <button id="registerCollectionBtn" class="flex-1 p-2 bg-indigo-600 rounded text-sm">Register (permissionless)</button>
      </div>
      <div class="mt-3">
        <h4 class="font-semibold">Admin: Set / Upgrade Collection Tier</h4>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mt-2">
          <input id="adminCollAddr" placeholder="Collection address (admin action)" class="p-2 rounded bg-black/20 text-sm" />
			<div id="adminStatusInfo" class="text-xs text-slate-400 mt-1">Status: —</div>
          <input id="adminDeclaredSupply" placeholder="Declared supply (uint32)" class="p-2 rounded bg-black/20 text-sm" />
        </div>
        <div class="flex gap-2 mt-2">
          <select id="adminTier" class="p-2 rounded bg-black/20 text-sm">
            <option value="0">UNVERIFIED (0)</option>
            <option value="1">VERIFIED (1)</option>
            <option value="2">BLUECHIP (2)</option>
          </select>
          <button id="adminSetConfigBtn" class="flex-1 p-2 bg-yellow-500 text-black rounded text-sm">Set Collection Config (admin)</button>
        </div>

		  <div class="mt-6 bg-slate-800/50 rounded-2xl shadow-lg p-4 border border-white/10">
  <h4 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
    ⚙️ Admin: Manage Registered Collections
  </h4>

  <!-- Input -->
  <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
    <input 
      id="manageCollAddr" 
      placeholder="Enter collection address" 
      class="p-3 rounded-lg bg-slate-900/60 border border-slate-700/40 text-sm text-white placeholder-slate-400 focus:ring-2 focus:ring-indigo-500 focus:outline-none" 
    />
  </div>
			  <div id="manageStatusInfo" class="text-xs text-slate-400 mt-1">Status: —</div>

  <!-- Action Buttons -->
  <div class="grid grid-cols-1 md:grid-cols-3 gap-3 mt-4">
    <button 
      id="removeCollectionBtn" 
      class="p-3 rounded-lg bg-red-600 hover:bg-red-700 transition text-sm font-medium shadow-md">
      🗑 Remove Collection
    </button>
    <button 
      id="forfeitEscrowBtn" 
      class="p-3 rounded-lg bg-amber-500 hover:bg-amber-600 transition text-sm font-medium text-black shadow-md">
      ⏳ Forfeit Escrow
    </button>
    <button 
      id="setBluechipBtn" 
      class="p-3 rounded-lg bg-blue-600 hover:bg-blue-700 transition text-sm font-medium shadow-md">
      💎 Toggle Bluechip
    </button>
  </div>

  <!-- Hint -->
  <p class="mt-3 text-xs text-slate-400">
    * These actions require <span class="font-semibold text-amber-300">admin privileges</span>. 
    Make sure your connected wallet has the proper role.
  </p>
</div>
      </div>
    </section>

    <!-- Bluechip -->
<section id="bluechip" class="tab-content hidden">
  <h2 class="font-semibold mb-2">Bluechip</h2>
  <p class="text-sm text-slate-300 mb-3">
    Enroll as a Bluechip wallet and harvest rewards from Bluechip collections.
  </p>

  <div class="space-y-3 text-sm">
    <!-- Enroll -->
    <div class="flex gap-2">
      <button id="enrollBluechipBtn" class="flex-1 p-2 bg-amber-500 text-black rounded">
        🌟 Enroll Bluechip Wallet
      </button>
    </div>

    <!-- Harvest -->
    <div class="grid grid-cols-2 gap-2">
      <input
        id="bluechipCollectionInput"
        placeholder="Bluechip Collection Address"
        class="p-2 rounded bg-black/20"
      />
		<div id="bluechipStatusInfo" class="text-xs text-slate-400 mt-1">Status: —</div>
      <button id="harvestBluechipBtn" class="p-2 bg-sky-600 hover:bg-sky-500 rounded">
        🎁 Harvest Bluechip
      </button>
    </div>

    <hr class="border-slate-700 my-3" />

    <!-- Wallet Info -->
<h3 class="text-base font-semibold mb-2 text-slate-200 flex items-center gap-2">
  🌟 My Bluechip Status
</h3>

<div class="grid grid-cols-2 gap-3 text-center">
  <!-- Enrollment Status -->
  <div class="p-3 rounded-xl bg-slate-800/60 shadow-md">
    <div class="text-slate-400 text-xs">Status</div>
    <div id="bluechipStatus" class="font-bold text-sm text-slate-100">—</div>
  </div>


  <!-- Last Harvest Block -->
  <div class="p-3 rounded-xl bg-slate-800/60 shadow-md">
    <div class="text-slate-400 text-xs">Last Harvest</div>
    <div id="bluechipLastBlock" class="font-mono text-xs text-indigo-400">—</div>
  </div>

  <!-- Enrollment Fee -->
  <div class="p-3 rounded-xl bg-slate-800/60 shadow-md">
    <div class="text-slate-400 text-xs">Enrollment Fee</div>
    <div id="bluechipFee" class="font-bold text-sm text-amber-400">—</div>
  </div>
</div>

<button
  id="refreshBluechipBtn"
  class="mt-3 w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg font-medium text-sm transition"
>
  🔄 Refresh Bluechip Info
</button>
  </div>
</section>

    <!-- Staking -->
<section id="staking" class="tab-content hidden">
  <h2 class="font-semibold mb-2">Staking</h2>
  <p class="text-sm text-slate-300 mb-3">Approve NFT → Term Stake or Permanent Stake → Harvest / Unstake</p>
  
  <div class="space-y-2 text-sm">
    <!-- Single NFT Stake -->
    <div class="grid grid-cols-2 gap-2">
      <input id="nftCollection" placeholder="NFT Collection Address" class="p-2 rounded bg-black/20" />
		<div id="nftStatusInfo" class="text-xs text-slate-400 mt-1">Status: —</div>
      <input id="nftTokenId" placeholder="Token ID" class="p-2 rounded bg-black/20" />
    </div>
    <div class="flex gap-2">
      <button id="approveNFTBtn" class="flex-1 p-2 bg-yellow-500 text-black rounded">Approve Staking Contract</button>
      <button id="termStakeBtn" class="flex-1 p-2 bg-indigo-600 rounded">Term Stake</button>
    </div>
    <div class="flex gap-2">
      <button id="permApproveFeeBtn" class="flex-1 p-2 bg-amber-600 rounded">Approve Fee (CATA)</button>
      <button id="permStakeBtn" class="flex-1 p-2 bg-emerald-600 text-black rounded">Permanent Stake</button>
    </div>
    <div class="flex gap-2">
      <button id="harvestBtn" class="flex-1 p-2 bg-sky-600 rounded">Harvest</button>
      <button id="unstakeBtn" class="flex-1 p-2 bg-red-600 rounded">Unstake</button>
    </div>

    <hr class="border-slate-700 my-2" />

    <!-- Batch Staking -->
    <h3 class="text-sm font-semibold mb-1">Batch Operations</h3>
    <textarea id="batchNFTs" placeholder="collection,tokenId per line" class="w-full p-2 rounded bg-black/20 text-sm h-28 font-mono"></textarea>
    <div class="flex gap-2 mt-2">
      <button id="batchTermStakeBtn" class="flex-1 p-2 bg-indigo-500 rounded text-sm">Batch Term Stake</button>
      <button id="batchPermStakeBtn" class="flex-1 p-2 bg-emerald-500 rounded text-sm">Batch Permanent Stake</button>
      <button id="batchUnstakeBtn" class="flex-1 p-2 bg-red-500 rounded text-sm">Batch Unstake</button>
    </div>

    <hr class="border-slate-700 my-2" />

    <!-- Batch Harvest -->
    <h3 class="text-sm font-semibold mb-1">Batch Harvest</h3>
    <textarea id="batchHarvestNFTs" placeholder="collection,tokenId per line" class="w-full p-2 rounded bg-black/20 text-sm h-28 font-mono"></textarea>
    <div class="flex gap-2 mt-2">
      <button id="batchHarvestBtn" class="flex-1 p-2 bg-sky-600 rounded text-sm">Batch Harvest</button>
    </div>

    <hr class="border-slate-700 my-2" />

    <!-- Extra Features -->
<h3 class="text-base font-semibold mb-2 text-slate-200 flex items-center gap-2">
  ⚡ Other Actions
</h3>
<div class="grid gap-3 sm:grid-cols-2">
  <!-- Pending Rewards -->
  <div class="p-3 rounded-xl bg-gradient-to-r from-slate-800 to-slate-900 shadow-md">
    <button id="pendingRewardsBtn" class="w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium transition">
      🎁 Check Pending Rewards
    </button>
    <div id="pendingRewardsResult" class="mt-2 text-xs text-slate-300 font-mono">—</div>
  </div>

  <!-- Portfolio -->
  <div class="p-3 rounded-xl bg-gradient-to-r from-slate-800 to-slate-900 shadow-md">
    <button id="viewPortfolioBtn" class="w-full p-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium transition">
      📂 View My Staked NFTs
    </button>
    <div id="portfolioResult" class="mt-2 text-xs text-slate-300 font-mono break-all">—</div>
  </div>
</div>

<hr class="border-slate-700 my-4" />

<!-- Staking Stats -->
<h3 class="text-base font-semibold mb-2 text-slate-200 flex items-center gap-2">
  📊 Staking Stats
</h3>
<div class="grid grid-cols-3 gap-3 text-center">
  <div class="p-3 rounded-lg bg-slate-800/60 shadow">
    <div class="text-slate-400 text-xs">Total</div>
    <div id="stakedAll" class="font-bold text-lg text-slate-100">—</div>
  </div>
  <div class="p-3 rounded-lg bg-slate-800/60 shadow">
    <div class="text-slate-400 text-xs">Term</div>
    <div id="stakedTerm" class="font-bold text-lg text-indigo-400">—</div>
  </div>
  <div class="p-3 rounded-lg bg-slate-800/60 shadow">
    <div class="text-slate-400 text-xs">Perm</div>
    <div id="stakedPerm" class="font-bold text-lg text-emerald-400">—</div>
  </div>
</div>
<button id="refreshStakingStatsBtn" class="mt-3 w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium transition">
  🔄 Refresh Staking Stats
</button>
  </div>
</section>

<!-- Governance -->
<section id="governance" class="tab-content hidden">
  <h2 class="font-semibold mb-2">Governance DAO</h2>
  <p class="text-sm text-slate-300 mb-3">
    Create proposals, vote, execute them, and monitor governance activity.
  </p>

  <!-- Proposal Creator -->
  <div class="glass p-4 rounded-lg space-y-3">
    <h3 class="font-semibold">Create Proposal</h3>

    <!-- Proposal type -->
    <select id="proposalType" class="w-full p-2 rounded bg-black/20 text-sm">
      <optgroup label="📊 Protocol Parameters">
        <option value="BASE_REWARD">Base Reward</option>
        <option value="HARVEST_FEE">Harvest Fee</option>
        <option value="UNSTAKE_FEE">Unstake Fee</option>
        <option value="REGISTRATION_FEE_FALLBACK">Registration Fee Fallback</option>
        <option value="VOTING_PARAM">Voting Parameter</option>
        <option value="TIER_UPGRADE">Tier Upgrade</option>
      </optgroup>

      <optgroup label="🛡 Guardian Council Ops">
        <option value="COUNCIL_RESEED_ACTIVE">Reseed Guardians (Active)</option>
        <option value="COUNCIL_PROPOSE_STANDBY">Propose Guardians (Standby)</option>
        <option value="COUNCIL_COMMIT_STANDBY">Commit Guardians (Standby)</option>
        <option value="COUNCIL_ACTIVATE_STANDBY">Activate Guardians (Standby)</option>
        <option value="COUNCIL_PROPOSE_NEW_DAO">Propose New DAO</option>
        <option value="COUNCIL_COMMIT_NEW_DAO">Commit New DAO</option>
        <option value="COUNCIL_CLEAR_LOCK">Clear Lock/Warning</option>
        <option value="UPGRADE_COUNCIL">Upgrade Council Implementation</option>
      </optgroup>
    </select>

    <!-- Generic fields -->
    <input id="proposalValue" placeholder="New numeric value" class="w-full p-2 rounded bg-black/20 text-sm" />
    <input id="proposalCollectionCtx" placeholder="Collection context (optional)" class="w-full p-2 rounded bg-black/20 text-sm" />
    <input id="paramTarget" placeholder="paramTarget (for VotingParam/TierUpgrade)" class="w-full p-2 rounded bg-black/20 text-sm" />

    <!-- Tier Upgrade -->
    <div id="tierUpgradeRow" class="grid grid-cols-1 md:grid-cols-3 gap-2 hidden">
      <select id="tierTo" class="p-2 rounded bg-black/20 text-sm">
        <option value="0">UNVERIFIED (0)</option>
        <option value="1">VERIFIED (1)</option>
        <option value="2">BLUECHIP (2)</option>
      </select>
      <input id="tierCollection" placeholder="Collection address" class="p-2 rounded bg-black/20 text-sm" />
      <input id="tierDeclaredSupply" placeholder="Declared supply (uint32)" class="p-2 rounded bg-black/20 text-sm" />
    </div>

    <!-- Council batch -->
    <div id="councilBatchRow" class="hidden space-y-2">
      <p class="text-xs text-slate-400">Enter 7 guardian addresses for new batch:</p>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 1" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 2" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 3" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 4" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 5" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 6" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 7" />
      </div>
    </div>

    <!-- New DAO -->
    <div id="newDaoRow" class="hidden">
      <input id="govNewDaoAddr" placeholder="New DAO contract address" class="w-full p-2 rounded bg-black/20 text-sm" />
    </div>

    <!-- Upgrade council -->
    <div id="upgradeCouncilRow" class="hidden">
      <input id="newCouncilImpl" placeholder="New council implementation address" class="w-full p-2 rounded bg-black/20 text-sm" />
    </div>

    <button id="createProposalBtn" class="w-full p-2 bg-violet-600 rounded">Create Proposal</button>
  </div>

  <!-- Voting & Execution -->
  <div class="glass p-4 rounded-lg space-y-3 mt-4">
    <h3 class="font-semibold">Vote & Execute</h3>
    <input id="proposalId" placeholder="Proposal ID (hex)" class="w-full p-2 rounded bg-black/20 text-sm" />
    <div class="flex gap-2">
      <button id="voteProposalBtn" class="flex-1 p-2 bg-blue-600 rounded">Vote</button>
      <button id="execProposalBtn" class="flex-1 p-2 bg-green-700 rounded">Execute</button>
    </div>
    <button id="fetchProposalBtn" class="w-full p-2 bg-slate-600 rounded">Fetch Proposal Details</button>
  </div>

  <!-- Proposals Explorer -->
  <div class="glass p-4 rounded-lg mt-4">
    <h3 class="font-semibold mb-2">Proposals Explorer</h3>
    <div class="overflow-x-auto">
      <table class="w-full text-sm">
        <thead class="text-xs text-slate-400">
          <tr>
            <th class="p-2">ID</th>
            <th class="p-2">Type</th>
            <th class="p-2">Value</th>
            <th class="p-2">Context</th>
            <th class="p-2">Proposer</th>
            <th class="p-2">Votes</th>
            <th class="p-2">Executed</th>
            <th class="p-2">Action</th>
          </tr>
        </thead>
        <tbody id="proposalsTbody"></tbody>
      </table>
    </div>
  </div>
</section>

<section id="council" class="tab-content hidden">
  <h2 class="font-semibold mb-2">DRS Guardian Council</h2>
  <p class="text-sm text-slate-300 mb-3">
    Manage guardian batches, DAO rotation, and emergency recovery.
  </p>

  <!-- DAO Rotation -->
  <div class="space-y-2 text-sm">
    <div class="grid grid-cols-2 gap-2">
      <input id="councilNewDaoAddr" placeholder="New DAO address" class="p-2 rounded bg-black/20" />
      <button id="proposeDaoBtn" class="p-2 bg-indigo-600 rounded">Propose DAO</button>
    </div>
    <button id="commitDaoBtn" class="w-full p-2 bg-indigo-400 rounded">Commit DAO</button>
  </div>

  <hr class="border-slate-700 my-2" />

  <!-- Guardian Batches -->
  <div class="space-y-2 text-sm">
    <textarea id="activeBatchInput" placeholder="7 addresses, one per line"
      class="w-full p-2 rounded bg-black/20 h-28 font-mono"></textarea>
    <div class="flex gap-2">
      <button id="proposeActiveBatchBtn" class="flex-1 p-2 bg-amber-600 rounded">Propose Active Batch</button>
      <button id="commitActiveBatchBtn" class="flex-1 p-2 bg-amber-400 rounded">Commit Active Batch</button>
    </div>
  </div>

  <div class="space-y-2 text-sm mt-3">
    <textarea id="standbyBatchInput" placeholder="7 addresses, one per line"
      class="w-full p-2 rounded bg-black/20 h-28 font-mono"></textarea>
    <div class="flex gap-2">
      <button id="proposeStandbyBatchBtn" class="flex-1 p-2 bg-emerald-600 rounded">Propose Standby Batch</button>
      <button id="commitStandbyBatchBtn" class="flex-1 p-2 bg-emerald-400 rounded">Commit Standby Batch</button>
    </div>
    <button id="activateStandbyBtn" class="w-full p-2 bg-green-600 rounded mt-2">Activate Standby</button>
  </div>

  <hr class="border-slate-700 my-2" />

  <!-- Lock -->
  <div class="space-y-2 text-sm">
    <button id="clearLockBtn" class="w-full p-2 bg-slate-600 rounded">Clear Lock/Warning</button>
  </div>

  <hr class="border-slate-700 my-2" />

  <!-- Recovery -->
  <h3 class="text-sm font-semibold mb-1">Recovery Request</h3>
  <div class="space-y-2 text-sm">
    <select id="recoveryKind" class="w-full p-2 rounded bg-black/20">
      <option value="0">Deployer</option>
      <option value="1">Admin</option>
    </select>
    <input id="recoveryProposed" placeholder="Proposed address" class="w-full p-2 rounded bg-black/20" />
    <input id="recoveryCallTarget" placeholder="Target contract address" class="w-full p-2 rounded bg-black/20" />
    <input id="recoveryFunction" placeholder="Function (e.g. upgradeTo(address))" class="w-full p-2 rounded bg-black/20" />
    <input id="recoveryArgs" placeholder="Arguments (comma-separated)" class="w-full p-2 rounded bg-black/20" />
    <textarea id="recoveryCallData" placeholder="Calldata (auto-generated 0x...)" class="w-full p-2 rounded bg-black/20 font-mono h-20"></textarea>
    <button id="encodeCallDataBtn" class="w-full p-2 bg-blue-600 rounded">Encode CallData</button>
    <div class="flex gap-2 mt-2">
      <button id="proposeRecoveryBtn" class="flex-1 p-2 bg-red-600 rounded">Propose</button>
      <button id="approveRecoveryBtn" class="flex-1 p-2 bg-orange-600 rounded">Approve</button>
      <button id="executeRecoveryBtn" class="flex-1 p-2 bg-green-600 rounded">Execute</button>
      <button id="vetoRecoveryBtn" class="flex-1 p-2 bg-slate-600 rounded">Veto</button>
    </div>
  </div>

  <hr class="border-slate-700 my-2" />

  <!-- Read-only DAO + Guardians -->
  <h3 class="text-base font-semibold mb-2">DAO State</h3>
  <div class="p-3 rounded-lg bg-slate-800/60 shadow text-sm space-y-3">
    <div>
      <div class="text-slate-400 text-xs">Current DAO</div>
      <div id="daoAddr" class="font-mono text-slate-100 break-all">—</div>
    </div>
    <div>
      <div class="text-slate-400 text-xs">Pending DAO</div>
      <div id="pendingDaoAddr" class="font-mono text-slate-100 break-all">—</div>
    </div>
    <div>
      <div class="text-slate-400 text-xs">Commit Window</div>
      <div id="pendingDaoWindow" class="font-mono text-slate-100">—</div>
    </div>
  </div>
  <button id="refreshDaoBtn" class="mt-3 w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">🔄 Refresh DAO</button>

  <h3 class="text-base font-semibold mt-6 mb-2">Guardians</h3>
  <div class="grid grid-cols-2 gap-3 text-sm">
    <div class="p-3 rounded-lg bg-slate-800/60 shadow">
      <div class="text-slate-400 text-xs">Active</div>
      <pre id="activeGuardians" class="font-mono text-slate-100 whitespace-pre-wrap h-24 overflow-y-auto">—</pre>
    </div>
    <div class="p-3 rounded-lg bg-slate-800/60 shadow">
      <div class="text-slate-400 text-xs">Standby</div>
      <pre id="standbyGuardians" class="font-mono text-slate-100 whitespace-pre-wrap h-24 overflow-y-auto">—</pre>
    </div>
    <div class="col-span-2 p-3 rounded-lg bg-slate-800/60 shadow">
      <div class="text-slate-400 text-xs">Pending Active Batch</div>
      <pre id="pendingActiveGuardians" class="font-mono text-slate-100 whitespace-pre-wrap h-24 overflow-y-auto">—</pre>
      <div class="text-slate-400 text-xs mt-2">Commitment Window</div>
      <div id="pendingActiveWindow" class="font-mono text-slate-100">—</div>
    </div>
    <div class="col-span-2 p-3 rounded-lg bg-slate-800/60 shadow">
      <div class="text-slate-400 text-xs">Pending Standby Batch</div>
      <pre id="pendingStandbyGuardians" class="font-mono text-slate-100 whitespace-pre-wrap h-24 overflow-y-auto">—</pre>
      <div class="text-slate-400 text-xs mt-2">Commitment Window</div>
      <div id="pendingStandbyWindow" class="font-mono text-slate-100">—</div>
    </div>
  </div>
  <button id="refreshGuardiansBtn" class="mt-3 w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">🔄 Refresh Guardians</button>

  <h3 class="text-base font-semibold mt-6 mb-2">Lock Status</h3>
  <div class="p-3 rounded-lg bg-slate-800/60 shadow text-sm">
    <div class="text-slate-400 text-xs">Status</div>
    <div id="lockStatus" class="font-mono text-slate-100">—</div>
  </div>
  <button id="refreshLockBtn" class="mt-3 w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm">🔄 Refresh Lock</button>
</section>
         

	  <div id="whitepaper" class="tab-content hidden">
  <div class="glass ring-1 rounded-2xl p-5 space-y-6">
    <h2 class="text-xl font-semibold">Whitepaper Summary</h2>

    <!-- Vision & Mission -->
    <details class="glass ring-1 rounded-lg p-4" open>
      <summary class="cursor-pointer font-medium text-slate-200">
        Vision &amp; Mission
      </summary>
      <p class="text-slate-300 text-sm mt-2 leading-relaxed">
        Catalyst aims to be the universal utility layer for NFTs: every ERC-721 can stake, burn, 
        and participate in governance. The protocol balances incentives between blue-chip collections, 
        verified custodial projects, and unverified projects — using proof-of-burn and escrow 
        forfeits for legitimacy.
      </p>
    </details>

    <!-- Tokenomics -->
    <details class="glass ring-1 rounded-lg p-4">
      <summary class="cursor-pointer font-medium text-slate-200">
        Tokenomics (CATA)
      </summary>
      <ul class="mt-2 text-sm text-slate-300 list-disc ml-5 space-y-1">
        <li>Immutable fee split: <span class="mono">90% Burn / 9% Treasury / 1% Deployer</span></li>
        <li>Global stake cap: <span class="mono">500M NFTs</span> (375M term, 125M permanent)</li>
        <li>Per-collection cap: <span class="mono">20k NFTs</span></li>
        <li>Token max supply: <span class="mono">1B CATA</span> (100M premint to initial admin)</li>
        <li>Minting restricted to <span class="mono">CatalystStaking</span></li>
      </ul>
    </details>

    <!-- Governance -->
    <details class="glass ring-1 rounded-lg p-4">
      <summary class="cursor-pointer font-medium text-slate-200">
        Governance
      </summary>
      <p class="text-slate-300 text-sm mt-2 leading-relaxed">
        Burn-weighted voting with per-collection caps and stake-based weighting. 
        Proposals may adjust reward rates, fees, tiers, and reseed Guardian Council batches. 
        The <span class="mono">90 / 9 / 1</span> split is immutable by governance.
      </p>
    </details>

    <!-- Guardian Recovery -->
    <details class="glass ring-1 rounded-lg p-4">
      <summary class="cursor-pointer font-medium text-slate-200">
        Guardian Recovery (Batch Guardian Council)
      </summary>
      <p class="text-slate-300 text-sm mt-2 leading-relaxed">
        The Batch Guardian Council secures upgrades and recovery. Two rotating batches of 7 guardians 
        ensure failover. Recovery requires 5-of-7 approvals, 6-of-7 triggers a warning with a 
        48h Last Honest veto, and 7-of-7 forces auto-lock with standby activation.
      </p>
    </details>

    <div class="text-xs text-slate-400">
      Read the full paper for detailed math, proofs, and edge cases.
    </div>
  </div>
</div>
</div>
</main>

    <section class="glass p-4 rounded-lg mt-6">
      <h3 class="font-semibold mb-2">Advanced / Logs</h3>
      <div id="logs" class="h-48 overflow-auto text-xs font-mono bg-black/20 p-3 rounded"></div>
    </section>

    <footer class="mt-6 text-xs text-slate-500 text-center">
  © Catalyst Protocol — Decentralized &amp; Community-Governed.<br />
  <span class="block mt-1">All contracts are upgradeable via DAO &amp; Batch Guardian Council. Use at your own risk.</span>
</footer>
  </div>

  <!-- load ethers first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
	
  <script>
  /************************************************************************
   * DApp main - dynamic ABI loading + wiring for CATA / Staking /
   * Governance / GuardianCouncil. Uses your uploaded contracts as spec.
   *
   * Note: ABIs must be provided at the ABI_URLS paths (json ABI files).
   * Put e.g. /abi/CataERC20Upgradeable.json, /abi/CatalystStakingUpgradeable.json, etc.
   ************************************************************************/

  // ---------- ABI URLs (external ABI JSONs) ----------
  const ABI_URLS = {
    cata: "../abi/CataERC20Upgradeable.json",
    staking: "../abi/CatalystStakingUpgradeable.json",
    governance: "../abi/CatalystGovernanceUpgradeable.json",
    council: "../abi/BatchGuardianCouncilUpgradeable.json"
  };

  // Minimal ERC-721 ABI kept inline (approval helpers)
  const ERC721_ABI = [
    'function approve(address to, uint256 tokenId)',
    'function setApprovalForAll(address operator, bool approved)',
    'function isApprovedForAll(address owner, address operator) view returns (bool)'
  ];

  // Default addresses (replace with your deployed addresses)
  const DEFAULT_ADDRS = {
    cata: "0x605bb62249E1b16049Ca6E69e70BCFEcD88c3E3D",
    staking: "0xa8Dd5EeEcF6eCc4Ff8A06881125ae95C0f777332",
    governance: "0x11D93F284754af1C543F61D7b04784fC974494A4",
    council: "0x5C1006247f7759C3f245312f2407AcE3351Db32A"
  };

	  // App state
	  let provider = null, signer = null, userAddr = null;
  let abis = {}, contracts = { cata:null, staking:null, governance:null, council:null };
	  
const $ = id => document.getElementById(id);
  function log(...args){
    const el = $('logs');
    try {
      el.innerText = new Date().toISOString() + ' • ' + args.map(a=>typeof a==='object'?JSON.stringify(a):a).join(' ') + '\n' + el.innerText;
    } catch(e) { console.log(...args); }
    console.log(...args);
  }

  // Fetch JSON with error handling
  async function fetchJSON(path){
    try {
      const res = await fetch(path);
      if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
      return await res.json();
    } catch (e) {
      log('fetchJSON err', path, e.message || e);
      return null;
    }
  }

  // Load ABIs from ABI_URLS
  async function loadABIs(){
    for(const k of Object.keys(ABI_URLS)){
      const j = await fetchJSON(ABI_URLS[k]);
      abis[k] = j; // null if failed
    }
    log('ABIs loaded', Object.keys(abis).map(k => `${k}:${abis[k]? 'ok':'missing'}`).join(' '));
  }

  // Save/load addresses to localStorage
  function saveAddrsToLocal(payload){
    try {
      localStorage.setItem('catalyst_addrs', JSON.stringify(payload));
      log('Saved addresses');
    } catch(e){ log('saveAddrs err', e); }
  }

  function loadSavedAddrs(){
    try {
      const raw = localStorage.getItem('catalyst_addrs');
      if(!raw){
        // prefill defaults
        $('addrCata').value = DEFAULT_ADDRS.cata;
        $('addrStaking').value = DEFAULT_ADDRS.staking;
        $('addrGovernance').value = DEFAULT_ADDRS.governance;
        $('addrCouncil').value = DEFAULT_ADDRS.council;
        log('Prefilled default addresses');
        return;
      }
      const obj = JSON.parse(raw);
      if(obj.addrCata) $('addrCata').value = obj.addrCata;
      if(obj.addrStaking) $('addrStaking').value = obj.addrStaking;
      if(obj.addrGovernance) $('addrGovernance').value = obj.addrGovernance;
      if(obj.addrCouncil) $('addrCouncil').value = obj.addrCouncil;
      log('Loaded saved addresses');
    } catch(e){ log('loadSavedAddrs err', e); }
  }

  // Attach contract instances (requires signer)
  async function attachContractsIfSet(){
    try {
      if(!provider || !signer) return;
      // ensure ABIs present (attempt load if missing)
      if(Object.keys(abis).length === 0 || Object.values(abis).every(v => v == null)) {
        await loadABIs();
      }
      const cataA = $('addrCata').value.trim();
      const stakingA = $('addrStaking').value.trim();
      const govA = $('addrGovernance').value.trim();
      const councilA = $('addrCouncil').value.trim();

      if(cataA && abis.cata) contracts.cata = new ethers.Contract(cataA, abis.cata, signer);
      else contracts.cata = null;

      if(stakingA && abis.staking) contracts.staking = new ethers.Contract(stakingA, abis.staking, signer);
      else contracts.staking = null;

      if(govA && abis.governance) contracts.governance = new ethers.Contract(govA, abis.governance, signer);
      else contracts.governance = null;

      if(councilA && abis.council) contracts.council = new ethers.Contract(councilA, abis.council, signer);
      else contracts.council = null;

      log('Contracts attached', {
        cata: !!contracts.cata,
        staking: !!contracts.staking,
        governance: !!contracts.governance,
        council: !!contracts.council
      });

      // fetch balances if available
      if(contracts.cata) await fetchCataBalance();
    } catch(e){ log('attachContractsIfSet err', e && e.message ? e.message : e); }
  }

  // Fetch CATA Balance (shows in readable numbers, e.g. "1.25 CATA")
async function fetchCataBalance(){
try {
if(!contracts.cata) return;
const bal = await contracts.cata.balanceOf(userAddr);
$('cataBal').innerText = ethers.utils.formatEther(bal) + ' CATA';
} catch(e){ log('fetchCataBalance err', e && e.message ? e.message : e); }
}


	  function shortenAddress(addr) {
  if (!addr) return "Not connected";
  return addr.slice(0, 6) + "..." + addr.slice(-4);
}


// ---------- Connect / Disconnect ----------
async function connect() {
  try {
    if (!window.ethereum) return alert('No Web3 wallet (install MetaMask)');

    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send('eth_requestAccounts', []);
    signer = provider.getSigner();
    userAddr = await signer.getAddress();

    // Shortened address + tooltip
    const addrEl = $('addr');
    addrEl.innerText = shortenAddress(userAddr);
    addrEl.title = userAddr;

    // Setup copy button
    $('copyAddrBtn').onclick = () => {
      navigator.clipboard.writeText(userAddr);
      alert("✅ Address copied!");
    };

    // Network
    const net = await provider.getNetwork();
    $('networkText').innerText = net.name + " (" + net.chainId + ")";

    // Toggle buttons
    $('connectBtn').classList.add('hidden');
    $('disconnectBtn').classList.remove('hidden');

    // Load contracts
    await loadABIs();
    await attachContractsIfSet();

    log("Connected", userAddr);
  } catch (e) {
    log("connect err", e?.message || e);
  }
}

function disconnect() {
  provider = signer = userAddr = null;
  contracts = { cata: null, staking: null, governance: null, council: null };

  // Reset UI
  const addrEl = $('addr');
  addrEl.innerText = "Not connected";
  addrEl.title = "";

  $('networkText').innerText = "—";
  $('cataBal').innerText = "—";

  $('connectBtn').classList.remove('hidden');
  $('disconnectBtn').classList.add('hidden');

  log("Disconnected");
}


// ---------- CATA functions ----------
// Burn (any holder)
async function cataBurn() {
  try {
    if (!contracts.cata) {
      await attachContractsIfSet();
      if (!contracts.cata) return alert('Set CATA contract address first');
    }

    const amtRaw = $('cataBurnAmt').value.trim();
    if (!amtRaw) return alert('Burn amount required');

    const amtWei = ethers.utils.parseEther(amtRaw);

    showLoading("Burning tokens...");
    const tx = await contracts.cata.burn(amtWei);
    log('cata.burn tx', tx.hash);
    await tx.wait();
    log('cata.burn completed');

    await fetchCataBalance();
    await fetchTransparency();
  } catch (e) {
    log('cataBurn err', e?.message || e);
    alert(`Burn failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

// Pause (admin only)
async function cataPause() {
  try {
    if (!contracts.cata) {
      await attachContractsIfSet();
      if (!contracts.cata) return alert('Set CATA contract address first');
    }

    showLoading("Pausing contract...");
    const tx = await contracts.cata.pause();
    log('cata.pause tx', tx.hash);
    await tx.wait();
    log('cata.pause completed');
  } catch (e) {
    log('cataPause err', e?.message || e);
    alert(`Pause failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

// Unpause (admin only)
async function cataUnpause() {
  try {
    if (!contracts.cata) {
      await attachContractsIfSet();
      if (!contracts.cata) return alert('Set CATA contract address first');
    }

    showLoading("Unpausing contract...");
    const tx = await contracts.cata.unpause();
    log('cata.unpause tx', tx.hash);
    await tx.wait();
    log('cata.unpause completed');
  } catch (e) {
    log('cataUnpause err', e?.message || e);
    alert(`Unpause failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

// Swap Admin (council only)
async function cataSwapAdmin() {
  try {
    if (!contracts.cata) {
      await attachContractsIfSet();
      if (!contracts.cata) return alert('Set CATA contract address first');
    }

    const newAdmin = $('swapNewAdmin').value.trim();
    const oldAdmin = $('swapOldAdmin').value.trim() || ethers.constants.AddressZero;

    if (!newAdmin) return alert('New admin address required');

    showLoading("Swapping admin...");
    const tx = await contracts.cata.swapAdmin(newAdmin, oldAdmin);
    log('cata.swapAdmin tx', tx.hash);
    await tx.wait();
    log('cata.swapAdmin completed');
  } catch (e) {
    log('cataSwapAdmin err', e?.message || e);
    alert(`Swap admin failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

// Transparency (view supply)
async function fetchTransparency() {
  try {
    if (!contracts.cata) {
      await attachContractsIfSet();
      if (!contracts.cata) return alert('Set CATA contract address first');
    }

    showLoading("Fetching transparency...");
    const totalSupply = await contracts.cata.totalSupply();
    const maxSupply = await contracts.cata.MAX_SUPPLY();
    const remainingMintable = maxSupply.sub(totalSupply);

    $('cataTotalSupply').innerText = ethers.utils.formatUnits(totalSupply, 18) + " CATA";
    $('cataMaxSupply').innerText = ethers.utils.formatUnits(maxSupply, 18) + " CATA";
    $('cataRemainingMintable').innerText = ethers.utils.formatUnits(remainingMintable, 18) + " CATA";
  } catch (e) {
    log('fetchTransparency err', e?.message || e);
    alert(`Transparency fetch failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

/********************************************************************
 * Loading Indicator
 ********************************************************************/
function showLoading() {
  $('loadingIndicator').style.display = 'block';
}
function hideLoading() {
  $('loadingIndicator').style.display = 'none';
}

/********************************************************************
 * Collection Registration logic
 ********************************************************************/
const MIN_ERC20_ABI = [
  'function allowance(address owner, address spender) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)'
];

const ONE = ethers.BigNumber.from("1000000000000000000");
const SMALL_MIN_FEE = ONE.mul(1);
const SMALL_MAX_FEE = ONE.mul(10);
const MED_MIN_FEE = ONE.mul(11);
const MED_MAX_FEE = ONE.mul(50);
const LARGE_MIN_FEE = ONE.mul(51);
const LARGE_MAX_FEE_CAP = ONE.mul(200);
const BP_DENOM = 10000;

function calculateRegistrationBaseFeeBN(declaredSupplyInt) {
  if (!Number.isInteger(declaredSupplyInt) || declaredSupplyInt < 1) {
    throw new Error('declaredSupply must be integer >= 1');
  }
  const dsBN = ethers.BigNumber.from(String(declaredSupplyInt));
  if (declaredSupplyInt <= 5000) {
    const numer = dsBN.mul(SMALL_MAX_FEE.sub(SMALL_MIN_FEE));
    return SMALL_MIN_FEE.add(numer.div(5000));
  } else if (declaredSupplyInt <= 10000) {
    const numer = dsBN.sub(5000).mul(MED_MAX_FEE.sub(MED_MIN_FEE));
    return MED_MIN_FEE.add(numer.div(5000));
  } else {
    const extra = declaredSupplyInt - 10000;
    const range = 10000;
    if (extra >= range) return LARGE_MAX_FEE_CAP;
    const numer = ethers.BigNumber.from(String(extra)).mul(LARGE_MAX_FEE_CAP.sub(LARGE_MIN_FEE));
    return LARGE_MIN_FEE.add(numer.div(range));
  }
}

async function computeTotalFeeBN(baseFeeBN, tier) {
  let multBP = BP_DENOM;
  try {
    if (tier === 0) {
      if (contracts.staking && typeof contracts.staking.unverifiedSurchargeBP === 'function') {
        const bp = await contracts.staking.unverifiedSurchargeBP();
        multBP = bp.toNumber();
      } else {
        multBP = 12000;
      }
    }
  } catch (e) {
    log('computeTotalFeeBN: could not read unverifiedSurchargeBP, using fallback 12000', e);
    if (tier === 0) multBP = 12000;
  }
  const total = baseFeeBN.mul(ethers.BigNumber.from(String(multBP))).div(ethers.BigNumber.from(String(BP_DENOM)));
  const surcharge = total.gt(baseFeeBN) ? total.sub(baseFeeBN) : ethers.BigNumber.from("0");
  return { totalFeeBN: total, surchargeBN: surcharge, multBP };
}

function fmtCata(bn) { return ethers.utils.formatEther(bn) + ' CATA'; }

function getCataERC20ContractInstance() {
  const cataAddr = $('addrCata').value.trim();
  if (!cataAddr) throw new Error('CATA address not set in UI');
  if (contracts.cata && typeof contracts.cata.allowance === 'function') return contracts.cata;
  return new ethers.Contract(cataAddr, MIN_ERC20_ABI, signer);
}

async function handleCalcRegFee() {
  showLoading();
  try {
    const supplyStr = $('regDeclaredSupply').value.trim();
    const collection = $('regCollectionAddr').value.trim();
    if (!supplyStr || !collection) return alert('collection and declared supply required for fee calc');
    const declaredSupply = parseInt(supplyStr, 10);
    const baseFeeBN = calculateRegistrationBaseFeeBN(declaredSupply);
    const tier = parseInt($('regTier').value, 10);
    const { totalFeeBN, surchargeBN, multBP } = await computeTotalFeeBN(baseFeeBN, tier);
    $('regFeeInfo').innerText = `Base: ${fmtCata(baseFeeBN)}  |  SurchargeBP: ${multBP}  |  Total: ${fmtCata(totalFeeBN)}  |  Surcharge: ${fmtCata(surchargeBN)}`;
    return { baseFeeBN, totalFeeBN, surchargeBN };
  } catch (e) {
    log('handleCalcRegFee err', e && e.message ? e.message : e);
    alert('Fee calc error: ' + (e.message || e));
  } finally {
    hideLoading();
  }
}

async function handleApproveForRegistration() {
  showLoading();
  try {
    if (!provider || !signer) return alert('connect wallet first');
    const stakingAddr = $('addrStaking').value.trim();
    if (!stakingAddr) return alert('set staking address first');
    const supplyStr = $('regDeclaredSupply').value.trim();
    const declaredSupply = parseInt(supplyStr, 10);
    if (!supplyStr || isNaN(declaredSupply)) return alert('enter declared supply to compute fee before approving');
    const baseFeeBN = calculateRegistrationBaseFeeBN(declaredSupply);
    const tier = parseInt($('regTier').value, 10);
    const { totalFeeBN } = await computeTotalFeeBN(baseFeeBN, tier);
    const cata = getCataERC20ContractInstance();
    const tx = await cata.approve(stakingAddr, totalFeeBN);
    log('approve tx', tx.hash);
    await tx.wait();
    log('approve completed for', fmtCata(totalFeeBN));
  } catch (e) {
    log('handleApproveForRegistration err', e && e.message ? e.message : e);
    alert('Approve failed: ' + (e.message || e));
  } finally {
    hideLoading();
  }
}

async function handleRegisterCollection() {
  showLoading();
  try {
    if (!provider || !signer) return alert('connect wallet first');
    const collection = $('regCollectionAddr').value.trim();
    const supplyStr = $('regDeclaredSupply').value.trim();
    if (!collection || !supplyStr) return alert('collection & declared supply required');
    const declaredSupply = parseInt(supplyStr, 10);
    const tier = parseInt($('regTier').value, 10);
    const baseFeeBN = calculateRegistrationBaseFeeBN(declaredSupply);
    const { totalFeeBN } = await computeTotalFeeBN(baseFeeBN, tier);
    const cata = getCataERC20ContractInstance();
    const myAddr = await signer.getAddress();
    const stakingAddr = $('addrStaking').value.trim();
    if (!stakingAddr) return alert('Set staking contract address first');
    const allowance = await cata.allowance(myAddr, stakingAddr);
    if (allowance.lt(totalFeeBN)) {
      const ok = confirm('You need to approve CATA for the registration fee: ' + fmtCata(totalFeeBN) + '. Approve now?');
      if (!ok) return;
      const txA = await cata.approve(stakingAddr, totalFeeBN);
      log('approve tx', txA.hash);
      await txA.wait();
      log('approve done');
    }
    if (!contracts.staking || typeof contracts.staking.registerCollection !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.registerCollection !== 'function') {
        return alert('staking contract ABI missing registerCollection function or contract not attached');
      }
    }
    const tx = await contracts.staking.registerCollection(collection, declaredSupply, tier);
    log('registerCollection tx', tx.hash);
    await tx.wait();
    log('registerCollection completed — watch CollectionAdded event for details');
  } catch (e) {
    log('handleRegisterCollection err', e && e.message ? e.message : e);
    alert('Register failed: ' + (e.message || e));
  } finally {
    hideLoading();
  }
}

async function handleAdminSetCollectionConfig() {
  showLoading();
  try {
    if (!provider || !signer) return alert('connect wallet first');
    if (!contracts.staking || typeof contracts.staking.setCollectionConfig !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.setCollectionConfig !== 'function') {
        return alert('staking contract ABI missing setCollectionConfig or contract not attached');
      }
    }
    const collection = $('adminCollAddr').value.trim();
    const declaredSupply = parseInt($('adminDeclaredSupply').value.trim(), 10);
    const tier = parseInt($('adminTier').value, 10);
    if (!collection || !declaredSupply) return alert('collection & declared supply required');
    const tx = await contracts.staking.setCollectionConfig(collection, declaredSupply, tier);
    log('setCollectionConfig tx', tx.hash);
    await tx.wait();
    log('setCollectionConfig completed (admin)');
  } catch (e) {
    log('handleAdminSetCollectionConfig err', e && e.message ? e.message : e);
    alert('Admin set failed: ' + (e.message || e));
  } finally {
    hideLoading();
  }
}

async function handleRemoveCollection() {
  showLoading();
  try {
    if (!provider || !signer) return alert('connect wallet first');
    if (!contracts.staking || typeof contracts.staking.removeCollection !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.removeCollection !== 'function') {
        return alert('staking contract ABI missing removeCollection or not attached');
      }
    }
    const collection = $('manageCollAddr').value.trim();
    if (!collection) return alert('collection required');
    const tx = await contracts.staking.removeCollection(collection);
    log('removeCollection tx', tx.hash);
    await tx.wait();
    log('Collection removed:', collection);
  } catch (e) {
    log('handleRemoveCollection err', e && e.message ? e.message : e);
    alert('Remove failed: ' + (e.message || e));
  } finally {
    hideLoading();
  }
}

async function handleForfeitEscrow() {
  showLoading();
  try {
    if (!provider || !signer) return alert('connect wallet first');
    if (!contracts.staking || typeof contracts.staking.forfeitEscrowIfExpired !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.forfeitEscrowIfExpired !== 'function') {
        return alert('staking contract ABI missing forfeitEscrowIfExpired or not attached');
      }
    }
    const collection = $('manageCollAddr').value.trim();
    if (!collection) return alert('collection required');
    const tx = await contracts.staking.forfeitEscrowIfExpired(collection);
    log('forfeitEscrowIfExpired tx', tx.hash);
    await tx.wait();
    log('Escrow forfeited for:', collection);
  } catch (e) {
    log('handleForfeitEscrow err', e && e.message ? e.message : e);
    alert('Forfeit failed: ' + (e.message || e));
  } finally {
    hideLoading();
  }
}

async function handleToggleBluechip() {
  showLoading();
  try {
    if (!provider || !signer) return alert('connect wallet first');
    if (!contracts.staking || typeof contracts.staking.setBluechipCollection !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.setBluechipCollection !== 'function') {
        return alert('staking contract ABI missing setBluechipCollection or not attached');
      }
    }
    const collection = $('manageCollAddr').value.trim();
    if (!collection) return alert('collection required');
    let newStatus = true;
    if (typeof contracts.staking.isBluechipCollection === 'function') {
      const current = await contracts.staking.isBluechipCollection(collection);
      newStatus = !current;
    }
    const tx = await contracts.staking.setBluechipCollection(collection, newStatus);
    log('setBluechipCollection tx', tx.hash);
    await tx.wait();
    log('Bluechip status updated:', collection, '=>', newStatus);
  } catch (e) {
    log('handleToggleBluechip err', e && e.message ? e.message : e);
    alert('Bluechip toggle failed: ' + (e.message || e));
  } finally {
    hideLoading();
  }
}


	  async function fetchCollectionStatus(addr) {
  if (!addr || addr.length !== 42) return "—"; // basic ETH address check

  try {
    const status = await contract.methods.getCollectionStatus(addr).call();
    switch (parseInt(status)) {
      case 0: return "❌ Not Registered";
      case 1: return "⚪ Unverified";
      case 2: return "✅ Verified";
      case 3: return "💎 Bluechip";
      default: return "—";
    }
  } catch (err) {
    console.error("Status check error:", err);
    return "⚠️ Error fetching status";
  }
}

	  function attachStatusChecker(inputId, statusDivId) {
  const inputEl = document.getElementById(inputId);
  const statusEl = document.getElementById(statusDivId);

  inputEl.addEventListener("input", async () => {
    const addr = inputEl.value.trim();
    statusEl.innerText = "⏳ Checking...";
    const result = await fetchCollectionStatus(addr);
    statusEl.innerText = `Status: ${result}`;
  });
}

// Attach to each field
attachStatusChecker("regCollectionAddr", "regStatusInfo");
attachStatusChecker("adminCollAddr", "adminStatusInfo");
attachStatusChecker("manageCollAddr", "manageStatusInfo");
// Attach status checkers to new fields
attachStatusChecker("bluechipCollectionInput", "bluechipStatusInfo");
attachStatusChecker("nftCollection", "nftStatusInfo");	  
	  

// ---------- Bluechip Actions ----------
// Enroll as Bluechip
async function enrollBluechip(){
  try {
    if(!contracts.staking){ 
      await attachContractsIfSet(); 
      if(!contracts.staking) return alert('Set staking contract'); 
    }
    if(typeof contracts.staking.enrollBluechip === 'function'){
      showLoading("Enrolling as Bluechip...");
      const tx = await contracts.staking.enrollBluechip();
      log('enrollBluechip tx', tx.hash);
      await tx.wait();
      log('enrollBluechip done');
    } else {
      alert('enrollBluechip not found in ABI');
    }
  } catch(e){ 
    log('enrollBluechip err', e?.message || e); 
    alert(`Enroll failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

// Harvest Bluechip
async function harvestBluechip(){
  try {
    const collection = document.getElementById('bluechipCollectionInput').value.trim();
    if(!collection) return alert('Enter a collection address');
    if(!contracts.staking){ 
      await attachContractsIfSet(); 
      if(!contracts.staking) return alert('Set staking contract'); 
    }
    if(typeof contracts.staking.harvestBluechip === 'function'){
      showLoading("Harvesting Bluechip rewards...");
      const tx = await contracts.staking.harvestBluechip(collection);
      log('harvestBluechip tx', tx.hash);
      await tx.wait();
      log('harvestBluechip done');
    } else {
      alert('harvestBluechip not found in ABI');
    }
  } catch(e){ 
    log('harvestBluechip err', e?.message || e); 
    alert(`Harvest failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

// Refresh Bluechip Info
async function refreshBluechip(){
  try {
    if(!contracts.staking){
      await attachContractsIfSet();
      if(!contracts.staking) return alert('Set staking contract');
    }
    if(typeof contracts.staking.bluechipWallets === 'function'){
      showLoading("Refreshing Bluechip info...");
      const me = await signer.getAddress();

      const enrolled = await contracts.staking.bluechipWallets(
        ethers.constants.AddressZero,
        me
      );
      $('bluechipStatus').innerText = enrolled ? '✅ Enrolled' : '❌ Not Enrolled';

      const lastBlock = await contracts.staking.bluechipLastHarvestBlock(
        ethers.constants.AddressZero,
        me
      );
      if(lastBlock.toString() !== '0'){
        const currentBlock = await provider.getBlockNumber();
        const diff = currentBlock - lastBlock.toNumber();
        const approxDays = (diff * 12) / (60 * 60 * 24); // ⏱ 12s per block → days
        $('bluechipLastBlock').innerText =
          `${lastBlock.toString()} (≈ ${approxDays.toFixed(2)} days ago)`;
      } else {
        $('bluechipLastBlock').innerText = '—';
      }

      const fee = await contracts.staking.bluechipWalletFee();
      const readableFee = ethers.utils.formatUnits(fee, 18); // assumes 18 decimals
      $('bluechipFee').innerText = `${readableFee} CATA`;

      log('refreshBluechip done');
    } else {
      alert('bluechipWallets not found in ABI');
    }
  } catch(e){ 
    log('refreshBluechip err', e?.message || e); 
    alert(`Refresh failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}
	  
// ---------- NFT approval ----------
async function approveNFT(){
  try {
    const collection = $('nftCollection').value.trim();
    if(!collection) return alert('collection required');
    const stakingAddr = $('addrStaking').value.trim();
    if(!stakingAddr) return alert('staking address required');
    const nft = new ethers.Contract(collection, ERC721_ABI, signer);
    const me = await signer.getAddress();

    showLoading("Approving NFT...");
    const already = await nft.isApprovedForAll(me, stakingAddr);
    if(already){ 
      log('already approved'); 
      alert('Already approved for staking');
      return; 
    }
    const tx = await nft.setApprovalForAll(stakingAddr, true);
    log('approve tx', tx.hash);
    await tx.wait();
    log('approve complete');
  } catch(e){ 
    log('approveNFT err', e?.message || e); 
    alert(`Approve failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

// ---------- Staking single ----------
async function termStake(){
  try {
    if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
    const collection = $('nftCollection').value.trim();
    const tokenId = $('nftTokenId').value.trim();
    if(!collection || !tokenId) return alert('collection & tokenId required');

    showLoading("Staking (term)...");
    const tx = await contracts.staking.termStake(collection, tokenId);
    log('termStake tx', tx.hash);
    await tx.wait();
    log('termStake done');
  } catch(e){ 
    log('termStake err', e?.message || e); 
    alert(`Stake failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

async function permanentStake(){
  try {
    if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
    const collection = $('nftCollection').value.trim();
    const tokenId = $('nftTokenId').value.trim();
    if(!collection || !tokenId) return alert('collection & tokenId required');

    showLoading("Staking (permanent)...");
    const tx = await contracts.staking.permanentStake(collection, tokenId);
    log('permanentStake tx', tx.hash);
    await tx.wait();
    log('permanentStake done');
  } catch(e){ 
    log('permanentStake err', e?.message || e); 
    alert(`Permanent stake failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

async function unstake(){
  try {
    if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
    const collection = $('nftCollection').value.trim();
    const tokenId = $('nftTokenId').value.trim();
    if(!collection || !tokenId) return alert('collection & tokenId required');

    showLoading("Unstaking...");
    const tx = await contracts.staking.unstake(collection, tokenId);
    log('unstake tx', tx.hash);
    await tx.wait();
    log('unstake done');
  } catch(e){ 
    log('unstake err', e?.message || e); 
    alert(`Unstake failed: ${e.message || e}`);
  } finally {
    hideLoading();
  }
}

// harvest - contract may or may not expose public harvest
async function harvest(){
  try {
    if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
    if(typeof contracts.staking.harvest === 'function'){
      const collection = $('nftCollection').value.trim();
      const tokenId = $('nftTokenId').value.trim();

      showLoading("Harvesting rewards...");
      const tx = await contracts.staking.harvest(collection, tokenId);
      log('harvest tx', tx.hash);
      await tx.wait();
      log('harvest done');
      return;
    }
    alert('No public harvest function found in staking ABI');
  } catch(e){ 
    log('harvest err', e?.message || e); 
    alert(e.message || e);
  } finally {
    hideLoading();
  }
}

	  // ---------- Batch helpers ----------
function parseBatchPairs() {
  const raw = $('batchNFTs').value.trim();
  if (!raw) return [];
  const lines = raw.split('\n').map(l => l.trim()).filter(l => l.length > 0);
  const pairs = [];
  for (const ln of lines) {
    const parts = ln.split(',').map(p => p.trim()).filter(p => p.length > 0);
    if (parts.length >= 2) pairs.push({ collection: parts[0], tokenId: parts[1] });
  }
  return pairs;
}

async function batchTermStake() {
  try {
    showLoading();

    const pairs = parseBatchPairs();
    if (pairs.length === 0) return alert('No pairs to stake');
    if (!contracts.staking) { 
      await attachContractsIfSet(); 
      if (!contracts.staking) return alert('Set staking contract'); 
    }

    if (typeof contracts.staking.batchTermStake === 'function') {
      const cols = pairs.map(p => p.collection);
      const ids = pairs.map(p => p.tokenId);
      const tx = await contracts.staking.batchTermStake(cols, ids);
      log('batchTermStake tx', tx.hash);
      await tx.wait();
      log('batchTermStake done');
    } else {
      // fallback sequential
      for (const p of pairs) {
        const tx = await contracts.staking.termStake(p.collection, p.tokenId);
        log('termStake seq tx', tx.hash);
        await tx.wait();
      }
      log('batchTermStake sequential done');
    }
  } catch (e) { 
    log('batchTermStake err', e && e.message ? e.message : e); 
  } finally {
    hideLoading();
  }
}

async function batchPermStake() {
  try {
    showLoading();

    const pairs = parseBatchPairs();
    if (pairs.length === 0) return alert('No pairs to stake');
    if (!contracts.staking) { 
      await attachContractsIfSet(); 
      if (!contracts.staking) return alert('Set staking contract'); 
    }

    if (typeof contracts.staking.batchPermanentStake === 'function') {
      const cols = pairs.map(p => p.collection);
      const ids = pairs.map(p => p.tokenId);
      const tx = await contracts.staking.batchPermanentStake(cols, ids);
      log('batchPermanentStake tx', tx.hash);
      await tx.wait();
      log('batchPermanentStake done');
    } else {
      for (const p of pairs) {
        const tx = await contracts.staking.permanentStake(p.collection, p.tokenId);
        log('permanentStake seq tx', tx.hash);
        await tx.wait();
      }
      log('batchPermStake sequential done');
    }
  } catch (e) { 
    log('batchPermStake err', e && e.message ? e.message : e); 
  } finally {
    hideLoading();
  }
}

async function batchUnstake() {
  try {
    showLoading();

    const pairs = parseBatchPairs();
    if (pairs.length === 0) return alert('No pairs to unstake');
    if (!contracts.staking) { 
      await attachContractsIfSet(); 
      if (!contracts.staking) return alert('Set staking contract'); 
    }

    if (typeof contracts.staking.batchUnstake === 'function') {
      const cols = pairs.map(p => p.collection);
      const ids = pairs.map(p => p.tokenId);
      const tx = await contracts.staking.batchUnstake(cols, ids);
      log('batchUnstake tx', tx.hash);
      await tx.wait();
      log('batchUnstake done');
    } else {
      for (const p of pairs) {
        const tx = await contracts.staking.unstake(p.collection, p.tokenId);
        log('unstake seq tx', tx.hash);
        await tx.wait();
      }
      log('batchUnstake sequential done');
    }
  } catch (e) { 
    log('batchUnstake err', e && e.message ? e.message : e); 
  } finally {
    hideLoading();
  }
}
 
async function batchHarvest() {
  try {
    const pairs = parseBatchHarvestPairs();
    if (pairs.length === 0) return alert('No pairs to harvest');

    if (!contracts || !contracts.staking) {
      if (typeof attachContractsIfSet === 'function') {
        await attachContractsIfSet();
      }
      if (!contracts || !contracts.staking) {
        return alert('Staking contract not set.');
      }
    }

    showLoading("Batch harvesting...");
    const byCollection = groupByCollection(pairs);
    const hasHarvestBatch = typeof contracts.staking.harvestBatch === 'function';
    const hasHarvestSingle = typeof contracts.staking.harvest === 'function';

    if (!hasHarvestBatch && !hasHarvestSingle) {
      return alert('Contract ABI lacks harvestBatch and harvest functions.');
    }

    for (const colLower of Object.keys(byCollection)) {
      const collection = colLower;
      const ids = byCollection[colLower];

      if (hasHarvestBatch) {
        log('calling harvestBatch for', collection, 'ids:', ids);
        const tx = await contracts.staking.harvestBatch(collection, ids);
        log('harvestBatch tx', tx.hash);
        await tx.wait();
        log('harvestBatch confirmed for', collection);
      } else {
        for (const id of ids) {
          log('calling harvest for', collection, id);
          const tx = await contracts.staking.harvest(collection, id);
          log('harvest tx', tx.hash);
          await tx.wait();
          log('harvest confirmed', id);
        }
      }
    }
    log('batchHarvest: done for all collections');
  } catch (err) {
    log('batchHarvest err', err?.message || err);
  } finally {
    hideLoading();
  }
}

	  // Helper: parse textarea "collection,tokenId" lines into objects
function parseBatchHarvestPairs() {
  try {
    showLoading();

    const txt = $('batchHarvestNFTs').value.trim();
    if (!txt) return [];

    return txt
      .split(/\r?\n/)
      .map(line => {
        const parts = line.split(',').map(s => s.trim()).filter(Boolean);
        if (parts.length < 2) return null;
        const collection = parts[0];
        const tokenId = parts[1];
        if (!collection || !tokenId) return null;
        return { collection, tokenId };
      })
      .filter(Boolean);

  } finally {
    hideLoading();
  }
}


// Check Pending Rewards
async function checkPendingRewards(){
  try {
    showLoading();

    const collection = $('nftCollection').value.trim();
    const tokenId = parseInt($('nftTokenId').value.trim(), 10);
    if(!collection) return alert('Enter a collection address');
    if(isNaN(tokenId)) return alert('Enter a valid token ID');

    if(!contracts.staking){   
      await attachContractsIfSet();   
      if(!contracts.staking) return alert('Set staking contract');   
    }  

    if(typeof contracts.staking.pendingRewards === 'function'){  
      const account = await getAccount();  
      const rewards = await contracts.staking.pendingRewards(collection, account, tokenId);  
      $('pendingRewardsResult').innerText = `${rewards.toString()} CATA`;  
      log('checkPendingRewards done');  
    } else {  
      alert('pendingRewards not found in ABI');  
    }

  } catch(e){
    log('checkPendingRewards err', e && e.message ? e.message : e);
    alert(e.message || e);
  } finally {
    hideLoading();
  }
}

// Refresh Staking Stats
async function refreshStakingStats(){
  try {
    showLoading();

    if(!contracts.staking){
      await attachContractsIfSet();
      if(!contracts.staking) return alert('Set staking contract');
    }

    if(typeof contracts.staking.totalStakedAll === 'function'){  
      const [all, term, perm] = await Promise.all([  
        contracts.staking.totalStakedAll(),  
        contracts.staking.totalStakedTerm(),  
        contracts.staking.totalStakedPerm()  
      ]);  

      $('stakedAll').innerText = all.toString();  
      $('stakedTerm').innerText = term.toString();  
      $('stakedPerm').innerText = perm.toString();  

      log('refreshStakingStats done');  
    } else {  
      alert('staking stats functions not found in ABI');  
    }

  } catch(e){
    log('refreshStakingStats err', e && e.message ? e.message : e);
    alert(e.message || e);
  } finally {
    hideLoading();
  }
}

// View Portfolio
async function viewPortfolio(){
  try {
    showLoading();

    const collection = $('nftCollection').value.trim();
    if(!collection) return alert('Enter a collection address');

    if(!contracts.staking){   
      await attachContractsIfSet();  
      if(!contracts.staking) return alert('Set staking contract');  
    }  

    if(typeof contracts.staking.stakePortfolioByUser === 'function'){  
      const account = await getAccount();  
      const portfolio = await contracts.staking.stakePortfolioByUser(collection, account);  
      $('portfolioResult').innerText = portfolio.length > 0   
        ? portfolio.join(', ')   
        : 'No NFTs staked.';  

      log('viewPortfolio done');  
    } else {  
      alert('stakePortfolioByUser not found in ABI');  
    }

  } catch(e){
    log('viewPortfolio err', e && e.message ? e.message : e);
    alert(e.message || e);
  } finally {
    hideLoading();
  }
}

// Batch Harvest
async function batchHarvest() {
  try {
    showLoading();

    const pairs = parseBatchHarvestPairs();
    if (pairs.length === 0) {
      alert('No pairs to harvest');
      return;
    }

    if (!contracts || !contracts.staking) {  
      if (typeof attachContractsIfSet === 'function') {  
        await attachContractsIfSet();  
      }  
      if (!contracts || !contracts.staking) {  
        return alert('Staking contract not set. Set addresses and attach contracts first.');  
      }  
    }  

    const byCollection = groupByCollection(pairs);  
    const hasHarvestBatch = typeof contracts.staking.harvestBatch === 'function';  
    const hasHarvestSingle = typeof contracts.staking.harvest === 'function';  

    if (!hasHarvestBatch && !hasHarvestSingle) {  
      return alert('Contract ABI lacks harvestBatch and harvest functions.');  
    }  

    for (const colLower of Object.keys(byCollection)) {  
      const collection = colLower;  
      const ids = byCollection[colLower];  

      if (hasHarvestBatch) {  
        log('calling harvestBatch for', collection, 'ids:', ids);  
        const tx = await contracts.staking.harvestBatch(collection, ids);  
        log('harvestBatch tx', tx.hash);  
        await tx.wait();  
        log('harvestBatch confirmed for', collection);  
      } else {  
        for (const id of ids) {  
          log('calling harvest for', collection, id);  
          const tx = await contracts.staking.harvest(collection, id);  
          log('harvest tx', tx.hash);  
          await tx.wait();  
          log('harvest confirmed', id);  
        }  
      }  
    }  

    log('batchHarvest: done for all collections');
  } catch (err) {
    log('batchHarvest err', err && err.message ? err.message : err);
  } finally {
    hideLoading();
  }
}


  // ---------- Governance Section ----------
const PROPOSAL_MAPPING = {
  BASE_REWARD: 0,
  HARVEST_FEE: 1,
  UNSTAKE_FEE: 2,
  REGISTRATION_FEE_FALLBACK: 3,
  VOTING_PARAM: 4,
  TIER_UPGRADE: 5,
  COUNCIL_RESEED_ACTIVE: 6,
  COUNCIL_PROPOSE_STANDBY: 7,
  COUNCIL_COMMIT_STANDBY: 8,
  COUNCIL_ACTIVATE_STANDBY: 9,
  COUNCIL_PROPOSE_NEW_DAO: 10,
  COUNCIL_COMMIT_NEW_DAO: 11,
  COUNCIL_CLEAR_LOCK: 12,
  UPGRADE_COUNCIL: 13
};

// UI toggle fields
$('proposalType').addEventListener('change', () => {
  const type = $('proposalType').value;
  $('tierUpgradeRow').classList.add('hidden');
  $('councilBatchRow').classList.add('hidden');
  $('newDaoRow').classList.add('hidden');
  $('upgradeCouncilRow').classList.add('hidden');

  if (type === 'TIER_UPGRADE') $('tierUpgradeRow').classList.remove('hidden');
  if (type === 'COUNCIL_RESEED_ACTIVE' || type === 'COUNCIL_PROPOSE_STANDBY') $('councilBatchRow').classList.remove('hidden');
  if (type === 'COUNCIL_PROPOSE_NEW_DAO') $('newDaoRow').classList.remove('hidden');
  if (type === 'UPGRADE_COUNCIL') $('upgradeCouncilRow').classList.remove('hidden');
});

// Create Proposal
$('createProposalBtn').onclick = async () => {
  try {
    if (!contracts.governance) {
      await attachContractsIfSet();
      if (!contracts.governance) return alert('⚠️ Governance not set');
    }

    showLoading();

    const typeStr = $('proposalType').value;
    const pType = PROPOSAL_MAPPING[typeStr];

    let paramTarget = parseInt($('paramTarget').value || '0');
    let newValue = ethers.BigNumber.from($('proposalValue').value.trim() || '0');
    let ctx = $('proposalCollectionCtx').value.trim() || ethers.constants.AddressZero;

    if (typeStr === 'TIER_UPGRADE') {
      ctx = $('tierCollection').value.trim();
      paramTarget = parseInt($('tierTo').value);
      newValue = ethers.BigNumber.from($('tierDeclaredSupply').value || '0');
    } else if (typeStr === 'COUNCIL_RESEED_ACTIVE' || typeStr === 'COUNCIL_PROPOSE_STANDBY') {
      const addrs = Array.from(document.querySelectorAll('.councilAddr')).map(el => el.value.trim());
      if (addrs.length !== 7 || addrs.some(a => !ethers.utils.isAddress(a))) {
        hideLoading();
        return alert('⚠️ Must provide 7 valid guardian addresses');
      }
      const payload = await contracts.governance.encodeCouncilBatch(addrs);
      ctx = payload;
      newValue = 0;
      paramTarget = 0;
    } else if (typeStr === 'COUNCIL_PROPOSE_NEW_DAO') {
      ctx = $('govNewDaoAddr').value.trim();
      if (!ethers.utils.isAddress(ctx)) {
        hideLoading();
        return alert("⚠️ Invalid DAO address");
      }
    } else if (typeStr === 'UPGRADE_COUNCIL') {
      ctx = $('newCouncilImpl').value.trim();
      if (!ethers.utils.isAddress(ctx)) {
        hideLoading();
        return alert("⚠️ Invalid council implementation address");
      }
    }

    const tx = await contracts.governance.propose(pType, paramTarget, newValue, ctx);
    log('propose tx', tx.hash);
    await tx.wait();

    alert("✅ Proposal created!");
  } catch (e) {
    console.error(e);
    alert("❌ " + (e.reason || e.message || e));
  } finally {
    hideLoading();
  }
};

// Vote
$('voteProposalBtn').onclick = async () => {
  try {
    if (!contracts.governance) await attachContractsIfSet();
    const id = $('proposalId').value.trim();
    if (!id) return alert('⚠️ Proposal ID required');

    showLoading();
    const ctx = $('proposalCollectionCtx').value.trim() || ethers.constants.AddressZero;
    const tx = await contracts.governance.vote(id, ctx);
    await tx.wait();
    alert("✅ Vote cast!");
  } catch (e) {
    alert("❌ " + (e.reason || e.message || e));
  } finally {
    hideLoading();
  }
};

// Execute
$('execProposalBtn').onclick = async () => {
  try {
    if (!contracts.governance) await attachContractsIfSet();
    const id = $('proposalId').value.trim();
    if (!id) return alert('⚠️ Proposal ID required');

    showLoading();
    const tx = await contracts.governance.executeProposal(id);
    await tx.wait();
    alert("✅ Proposal executed!");
  } catch (e) {
    alert("❌ " + (e.reason || e.message || e));
  } finally {
    hideLoading();
  }
};

// Fetch Proposal
$('fetchProposalBtn').onclick = async () => {
  try {
    if (!contracts.governance) await attachContractsIfSet();
    const id = $('proposalId').value.trim();
    if (!id) return alert('⚠️ Proposal ID required');

    showLoading();
    const info = await contracts.governance.proposals(id).catch(() => null);
    hideLoading();

    if (info) {
      log('proposal fetch', info);
    } else {
      alert("⚠️ Proposal not found");
    }
  } catch (e) {
    hideLoading();
    alert("❌ " + (e.reason || e.message || e));
  }
};

    
	  // Parse helper for 7 addresses
function parse7(txt) {
    const arr = txt.split('\n').map(s => s.trim()).filter(Boolean);
    if (arr.length !== 7) throw new Error("Need exactly 7 addresses");
    return arr;
}
	  
// ---------- Guardian Council 
// ---------- Council JS ----------
// DAO Rotation
$('proposeDaoBtn').onclick = async () => {
  try {
    if (!contracts.council) return alert("Council not attached");
    showLoading();
    const newDao = $('councilNewDaoAddr').value.trim();
    if (!ethers.utils.isAddress(newDao)) throw new Error("Invalid DAO address");
    const tx = await contracts.council.proposeNewDAO(newDao);
    await tx.wait();
    alert("✅ DAO proposed");
  } catch (e) {
    alert("❌ " + (e.reason || e.message));
  } finally {
    hideLoading();
  }
};

$('commitDaoBtn').onclick = async () => {
  try {
    if (!contracts.council) return alert("Council not attached");
    showLoading();
    const tx = await contracts.council.commitNewDAO();
    await tx.wait();
    alert("✅ DAO committed");
  } catch (e) {
    alert("❌ " + (e.reason || e.message));
  } finally {
    hideLoading();
  }
};

// Guardian Batches
$('proposeActiveBatchBtn').onclick = async () => {
  try {
    showLoading();
    const arr = parse7($('activeBatchInput').value);
    const tx = await contracts.council.daoProposeSeedActiveBatch(arr);
    await tx.wait();
    alert("✅ Active batch proposed");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('commitActiveBatchBtn').onclick = async () => {
  try {
    showLoading();
    const tx = await contracts.council.daoCommitSeedActiveBatch();
    await tx.wait();
    alert("✅ Active batch committed");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('proposeStandbyBatchBtn').onclick = async () => {
  try {
    showLoading();
    const arr = parse7($('standbyBatchInput').value);
    const tx = await contracts.council.daoProposeSeedStandbyBatch(arr);
    await tx.wait();
    alert("✅ Standby batch proposed");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('commitStandbyBatchBtn').onclick = async () => {
  try {
    showLoading();
    const tx = await contracts.council.daoCommitSeedStandbyBatch();
    await tx.wait();
    alert("✅ Standby batch committed");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('activateStandbyBtn').onclick = async () => {
  try {
    showLoading();
    const tx = await contracts.council.daoActivateStandby();
    await tx.wait();
    alert("✅ Standby activated");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

// Lock
$('clearLockBtn').onclick = async () => {
  try {
    showLoading();
    const tx = await contracts.council.daoClearLockAndWarning();
    await tx.wait();
    alert("✅ Lock cleared");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

// Recovery
$('encodeCallDataBtn').onclick = async () => {
  try {
    const fnSig = $('recoveryFunction').value.trim();
    const args = $('recoveryArgs').value.trim().split(',').map(a => a.trim()).filter(Boolean);
    const iface = new ethers.utils.Interface([`function ${fnSig}`]);
    const fnName = fnSig.split('(')[0];
    $('recoveryCallData').value = iface.encodeFunctionData(fnName, args);
    alert("✅ Calldata encoded");
  } catch (e) { alert("❌ " + (e.message || e)); }
};

$('proposeRecoveryBtn').onclick = async () => {
  try {
    showLoading();
    const kind = parseInt($('recoveryKind').value, 10);
    const proposed = $('recoveryProposed').value.trim();
    const target = $('recoveryCallTarget').value.trim();
    const calldata = $('recoveryCallData').value.trim();
    const tx = await contracts.council.proposeRecovery(kind, proposed, target, calldata);
    await tx.wait();
    alert("✅ Recovery proposed");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('approveRecoveryBtn').onclick = async () => {
  try { showLoading(); const kind = parseInt($('recoveryKind').value, 10);
    const tx = await contracts.council.approveRecovery(kind); await tx.wait(); alert("✅ Recovery approved");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('executeRecoveryBtn').onclick = async () => {
  try { showLoading(); const kind = parseInt($('recoveryKind').value, 10);
    const tx = await contracts.council.executeRecovery(kind); await tx.wait(); alert("✅ Recovery executed");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('vetoRecoveryBtn').onclick = async () => {
  try { showLoading(); const kind = parseInt($('recoveryKind').value, 10);
    const tx = await contracts.council.lastHonestHaltAndPromote(kind); await tx.wait(); alert("✅ Recovery vetoed");
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

// ---------- Read-only State ----------

$('refreshDaoBtn').onclick = async () => {
  try {
    showLoading();
    const dao = await contracts.council.dao();
    const [pending, earliest, deadline] = await contracts.council.getPendingDAOState();
    $('daoAddr').innerText = dao;
    $('pendingDaoAddr').innerText = pending;
    $('pendingDaoWindow').innerText = `Earliest: ${new Date(earliest*1000).toLocaleString()} | Deadline: ${new Date(deadline*1000).toLocaleString()}`;
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('refreshGuardiansBtn').onclick = async () => {
  try {
    showLoading();
    const active = await contracts.council.getActiveGuardians();
    const standby = await contracts.council.getStandbyGuardians();
    const [pa, paEarliest, paDeadline] = await contracts.council.getPendingActiveBatchState();
    const [ps, psEarliest, psDeadline] = await contracts.council.getPendingStandbyBatchState();
    $('activeGuardians').innerText = active.join("\n");
    $('standbyGuardians').innerText = standby.join("\n");
    $('pendingActiveGuardians').innerText = pa.join("\n");
    $('pendingActiveWindow').innerText = `Earliest: ${new Date(paEarliest*1000).toLocaleString()} | Deadline: ${new Date(paDeadline*1000).toLocaleString()}`;
    $('pendingStandbyGuardians').innerText = ps.join("\n");
    $('pendingStandbyWindow').innerText = `Earliest: ${new Date(psEarliest*1000).toLocaleString()} | Deadline: ${new Date(psDeadline*1000).toLocaleString()}`;
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};

$('refreshLockBtn').onclick = async () => {
  try {
    showLoading();
    const locked = await contracts.council.locked();
    $('lockStatus').innerText = locked ? "🔒 Locked" : "✅ Unlocked";
  } catch (e) { alert("❌ " + (e.message || e)); } finally { hideLoading(); }
};



  // ---------- Bind UI on load ----------
  window.addEventListener('load', async ()=>{
  // Manually set the default addresses
  $('addrCata').value = DEFAULT_ADDRS.cata;
  $('addrStaking').value = DEFAULT_ADDRS.staking;
  $('addrGovernance').value = DEFAULT_ADDRS.governance;
  $('addrCouncil').value = DEFAULT_ADDRS.council;

  await loadABIs();

  // Connect / disconnect
  $('connectBtn').onclick = connect;
  $('disconnectBtn').onclick = disconnect;

  // Refreshes the contracts based on the addresses in the input fields
  $('saveAddrs').onclick = ()=>{
    if(signer) attachContractsIfSet();
  };

  $('loadAddrs').onclick = ()=>{
    if(signer) attachContractsIfSet();
  };
		
    // CATA
	$('cataBurnBtn').onclick = cataBurn;
  $('pauseBtn').onclick = cataPause;
  $('unpauseBtn').onclick = cataUnpause;
  $('swapAdminBtn').onclick = cataSwapAdmin;
	$('refreshTransparencyBtn').onclick = fetchTransparency;

	// Register Collection 
/** Wire handlers to new UI elements — call this inside your window load / UI ready handler */
function wireRegistrationUIs() {
  // Existing
  $('calcRegFeeBtn').onclick = handleCalcRegFee;
  $('approveRegCataBtn').onclick = handleApproveForRegistration;
  $('registerCollectionBtn').onclick = handleRegisterCollection;
  $('adminSetConfigBtn').onclick = handleAdminSetCollectionConfig;

  // New admin actions (safe checks in case button missing in DOM)
  if ($('removeCollectionBtn')) $('removeCollectionBtn').onclick = handleRemoveCollection;
  if ($('forfeitEscrowBtn')) $('forfeitEscrowBtn').onclick = handleForfeitEscrow;
  if ($('setBluechipBtn')) $('setBluechipBtn').onclick = handleToggleBluechip;
}

// call this after your existing UI init (e.g., at end of window.load)
wireRegistrationUIs();

// ---------- Bluechip Binds ----------
$('enrollBluechipBtn').onclick = enrollBluechip;
$('harvestBluechipBtn').onclick = harvestBluechip;
$('refreshBluechipBtn').onclick = refreshBluechip;
	  
    // Staking single
    $('approveNFTBtn').onclick = approveNFT;
    $('termStakeBtn').onclick = termStake;
    $('permApproveFeeBtn').onclick = async ()=>{ // approve CATA tokens for fees if CATA ABI exists
      try {
        if(!contracts.cata) { await attachContractsIfSet(); if(!contracts.cata) return alert('Set CATA contract'); }
        const stakingAddr = $('addrStaking').value.trim();
        if(!stakingAddr) return alert('staking address required');
        const amt = ethers.constants.MaxUint256;
        const tx = await contracts.cata.approve(stakingAddr, amt);
        log('approve CATA tx', tx.hash);
        await tx.wait();
        log('approve CATA done');
      } catch(e){ log('permApproveFee err', e && e.message ? e.message : e); }
    };
    $('permStakeBtn').onclick = permanentStake;
    $('unstakeBtn').onclick = unstake;
    $('harvestBtn').onclick = harvest;

    // Batch
    $('batchTermStakeBtn').onclick = batchTermStake;
    $('batchPermStakeBtn').onclick = batchPermStake;
    $('batchUnstakeBtn').onclick = batchUnstake;
$('batchHarvestBtn').onclick = batchHarvest;

	  // Extra staking binds
$('pendingRewardsBtn').onclick = checkPendingRewards;
$('refreshStakingStatsBtn').onclick = refreshStakingStats;
$('viewPortfolioBtn').onclick = viewPortfolio;
	  
    log('UI ready');
  });

	// Tab switching for top nav buttons
document.querySelectorAll('.tabbtn').forEach(btn => {
  btn.addEventListener('click', () => {
    const tab = btn.getAttribute('data-tab');

    // Toggle active button
    document.querySelectorAll('.tabbtn').forEach(b => b.classList.remove('tab-active'));
    btn.classList.add('tab-active');

    // Toggle tab content
    document.querySelectorAll('.tab-content').forEach(sec => sec.classList.add('hidden'));
    document.getElementById(tab).classList.remove('hidden');
  });
});

// Global function for internal links
function selectTab(tabId) {
  // Toggle active button
  document.querySelectorAll('.tabbtn').forEach(b => b.classList.remove('tab-active'));
  const btn = document.querySelector(`[data-tab="${tabId}"]`);
  if (btn) btn.classList.add('tab-active');

  // Toggle tab content
  document.querySelectorAll('.tab-content').forEach(sec => sec.classList.add('hidden'));
  const section = document.getElementById(tabId);
  if (section) section.classList.remove('hidden');
		}
	  
  </script>
</body>
</html>

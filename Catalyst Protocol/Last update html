<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catalyst Protocol ‚Äî DApp (Production-ready UI)</title>
  <meta name="description" content="Catalyst Protocol dApp ‚Äî staking, governance, council" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <style>
    body { background: linear-gradient(180deg,#041024 0%, #061426 100%); }
    .glass { background: rgba(255,255,255,0.03); backdrop-filter: blur(6px); }
	  .tabbtn {transition: all 0.2s ease-in-out;}
.tabbtn:hover {opacity: 0.85; transform: translateY(-1px);}
.tab-active {outline: 2px solid white; outline-offset: 2px;}
  </style>
</head>
<body class="min-h-screen text-white font-sans">
  <div class="max-w-6xl mx-auto p-6">
    <header class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-2xl font-bold">Catalyst Protocol</h1>
        <p class="text-sm text-slate-300">Staking ¬∑ Governance ¬∑ Guardian Council</p>
      </div>
      <div class="flex items-center gap-3">
        <div id="networkBadge" class="px-3 py-1 rounded-md text-sm glass">Network: <span id="networkName">‚Äî</span></div>
        <button id="connectBtn" class="px-4 py-2 bg-gradient-to-r from-green-500 to-cyan-400 rounded-md font-semibold text-black">Connect</button>
        <button id="disconnectBtn" class="px-4 py-2 bg-red-500 rounded-md font-semibold text-black hidden">Disconnect</button>
      </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-6 space-y-6">

<!-- Tab Buttons -->
<div class="glass ring-1 rounded-2xl p-4 flex flex-wrap gap-3 justify-center">
  <button data-tab="overview" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-sky-700 text-white hover:bg-sky-600 transition tab-active">
    üìñ Overview
  </button>

  <button data-tab="quickstatus" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-slate-700 text-white hover:bg-slate-600 transition">
    üß≠ Quick Status
  </button>

  <button data-tab="registration" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-indigo-700 text-white hover:bg-indigo-600 transition">
    üìù Collection Registration
  </button>

  <button data-tab="bluechip" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-amber-600 text-black hover:bg-amber-500 transition">
    üíé Bluechip
  </button>

  <button data-tab="staking" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-emerald-700 text-white hover:bg-emerald-600 transition">
    üì¶ Staking
  </button>

  <button data-tab="governance" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-violet-700 text-white hover:bg-violet-600 transition">
    üèõÔ∏è Governance DAO
  </button>

  <button data-tab="council" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-rose-700 text-white hover:bg-rose-600 transition">
    üõ°Ô∏è DRS Guardian Council
  </button>

  <button data-tab="whitepaper" 
    class="tabbtn px-5 py-2.5 rounded-lg bg-teal-700 text-white hover:bg-teal-600 transition">
    üìú Whitepaper
  </button>
</div>

  <!-- Tab Contents -->
  <div id="tabContents" class="glass rounded-2xl p-4">

<section>
  <div id="overview" class="tab-content">
    <div class="glass ring-1 rounded-2xl p-5 space-y-6">
      <!-- Header -->
      <div class="flex items-start gap-4">
        <div class="w-14 h-14 rounded-xl bg-slate-800 border border-slate-700 grid place-items-center text-2xl">
          üß≠
        </div>
        <div class="space-y-2">
          <h2 class="text-xl font-semibold">Catalyst at a Glance</h2>
          <p class="text-slate-300 leading-relaxed">
            Catalyst is a modular NFT staking &amp; governance protocol. Stake ERC-721s for CATA rewards, 
            participate in burn-weighted governance, and rely on the Batch Guardian Council recovery system. 
            The design enforces 
            <span class="chip">security</span>, <span class="chip">scalability</span>, and 
            <span class="chip">sustainability</span> through immutable economics and DAO-managed upgrades.
          </p>
        </div>
      </div>

      <!-- Info Cards -->
      <div class="grid md:grid-cols-3 gap-4">
        <!-- Mission -->
<div class="glass ring-1 rounded-xl p-4">
  <div class="text-sm text-slate-400 mb-1">Mission</div>
  <div class="font-semibold">Non-Profit R&amp;D Utility</div>
  <p class="text-slate-300 text-sm mt-2">
    Immutable fee split 
    <span class="mono">90% Burn / 9% Treasury / 1% Deployer</span>. 
    Catalyst itself is not profit-seeking ‚Äî fees are burned or directed to a 
    community-governed treasury that funds audits, grants, and continued research &amp; development.
  </p>
  <p class="text-slate-400 text-xs mt-2 leading-relaxed">
    This does not prevent participants from creating value: token holders benefit from deflationary supply, 
    builders can launch services on top of Catalyst, and communities gain legitimacy and rewards. 
    In short, Catalyst is a public-good protocol while its ecosystem can still generate profit and long-term value.
  </p>
</div>

        <!-- Usage -->
        <div class="card rounded-xl p-4 ring-1 glass">
          <div class="text-sm muted mb-2 flex items-center gap-2">
            <span class="badge">Usage</span>
            <span>How to use Catalyst</span>
          </div>
          <ol class="text-sm list-decimal ml-5 space-y-2 text-slate-300 leading-relaxed">
            <li>Locate and save your <span class="font-mono">proxy contract</span> address.</li>
            <li>Connect your wallet to enable <span class="chip">staking</span> and <span class="chip">governance</span> actions.</li>
            <li>Use the tabs to stake NFTs, submit votes, claim rewards, and interact with the Batch Guardian Council.</li>
          </ol>
        </div>

        <!-- Docs -->
        <div class="glass ring-1 rounded-xl p-4">
          <div class="text-sm text-slate-400 mb-1">Docs</div>
          <div class="space-y-1 text-sm text-slate-300">
            <div>
              <span class="badge">See the</span> 
              Whitepaper
              <a href="javascript:void(0)" 
                 class="text-sky-400 hover:text-sky-300 underline cursor-pointer"
                 onclick="selectTab('whitepaper')">
                 summary
              </a>
            </div>
            <div>
              <span class="badge">Review the</span>
              Technical Appendix
              <a href="javascript:void(0)" 
                 class="text-sky-400 hover:text-sky-300 underline cursor-pointer"
                 onclick="selectTab('appendix')">
                 details
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
	  
    <!-- Quick Status -->
<section id="quickstatus" class="tab-content hidden">
  <h2 class="font-semibold mb-3 text-lg text-slate-100">‚ö° Quick Status</h2>
<div class="grid grid-cols-2 gap-3 text-sm">
  <!-- Card -->
  <div class="p-3 rounded-xl bg-slate-800/50 shadow-sm border border-slate-700">
    <div class="text-slate-400 text-xs">Connected</div>
    <div id="addr" class="font-semibold text-slate-200">Not connected</div>
  </div>

  <!-- Card -->
  <div class="p-3 rounded-xl bg-slate-800/50 shadow-sm border border-slate-700">
    <div class="text-slate-400 text-xs">Network</div>
    <div id="networkText" class="font-semibold text-slate-200">‚Äî</div>
  </div>

  <!-- Card -->
  <div class="p-3 rounded-xl bg-slate-800/50 shadow-sm border border-slate-700">
    <div class="text-slate-400 text-xs">CATA Balance</div>
    <div id="cataBal" class="font-semibold text-green-400">‚Äî</div>
  </div>

  <!-- Card -->
  <div class="p-3 rounded-xl bg-slate-800/50 shadow-sm border border-slate-700">
    <div class="text-slate-400 text-xs">Staked NFTs</div>
    <div id="globalStaked" class="font-semibold text-indigo-400">‚Äî</div>
  </div>

  <!-- Card (full width) -->
  <div class="col-span-2 p-3 rounded-xl bg-slate-800/50 shadow-sm border border-slate-700">
    <div class="text-slate-400 text-xs">Roles (CATA / Staking)</div>
    <div id="roles" class="font-semibold text-slate-200">‚Äî</div>
  </div>
</div>

  <hr class="my-3 border-slate-700" />
  <div class="text-xs text-slate-300">Contract Addresses (defaults & localStorage)</div>
  <div class="mt-2 space-y-2">
    <input id="addrCata" placeholder="CATA Token Address" class="w-full p-2 rounded bg-black/20 text-sm" />
    <input id="addrStaking" placeholder="Staking Contract Address" class="w-full p-2 rounded bg-black/20 text-sm" />
    <input id="addrGovernance" placeholder="Governance Contract Address" class="w-full p-2 rounded bg-black/20 text-sm" />
    <input id="addrCouncil" placeholder="GuardianCouncil Address" class="w-full p-2 rounded bg-black/20 text-sm" />
    <div class="flex gap-2">
      <button id="saveAddrs" class="px-3 py-1 bg-slate-700 rounded text-sm">Save</button>
      <button id="loadAddrs" class="px-3 py-1 bg-slate-700/50 rounded text-sm">Load</button>
    </div>
  </div>

  <hr class="my-3 border-slate-700" />
  <div class="text-xs text-slate-400">CATA Actions</div>
  <div class="mt-2 space-y-2">
    <input id="cataMintTo" placeholder="Mint to address" class="w-full p-2 rounded bg-black/20 text-sm" />
    <input id="cataMintAmt" placeholder="Amount (wei or integer string)" class="w-full p-2 rounded bg-black/20 text-sm" />
    <div class="flex gap-2">
      <button id="cataMintBtn" class="flex-1 p-2 bg-indigo-600 rounded">Mint (MINTER_ROLE)</button>
      <button id="cataBurnBtn" class="flex-1 p-2 bg-red-600 rounded">Burn (self)</button>
    </div>
    <div class="flex gap-2 mt-2">
      <input id="swapNewAdmin" placeholder="New admin address" class="flex-1 p-2 rounded bg-black/20 text-sm" />
      <input id="swapOldAdmin" placeholder="Old admin address (optional)" class="flex-1 p-2 rounded bg-black/20 text-sm" />
    </div>
    <div class="mt-2">
      <button id="swapAdminBtn" class="p-2 bg-yellow-500 text-black rounded w-full">Swap Admin (council only)</button>
    </div>
  </div>
</section>

    <!-- Collection Registration -->
    <section id="registration" class="tab-content hidden">
      <h3 class="font-semibold mb-2">Collection Registration</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mb-2">
        <input id="regCollectionAddr" placeholder="Collection address (ERC721)" class="p-2 rounded bg-black/20 text-sm" />
        <input id="regDeclaredSupply" placeholder="Declared max supply (integer >=1)" class="p-2 rounded bg-black/20 text-sm" />
      </div>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
        <select id="regTier" class="p-2 rounded bg-black/20 text-sm">
          <option value="0">UNVERIFIED (0)</option>
          <option value="1">VERIFIED (1)</option>
          <option value="2">BLUECHIP (2)</option>
        </select>
        <button id="calcRegFeeBtn" class="p-2 bg-slate-600 rounded text-sm">Calculate Fee</button>
        <div id="regFeeInfo" class="p-2 text-xs text-slate-300">Fee: ‚Äî</div>
      </div>
      <div class="flex gap-2 mt-2">
        <button id="approveRegCataBtn" class="flex-1 p-2 bg-amber-600 rounded text-sm">Approve CATA for registration</button>
        <button id="registerCollectionBtn" class="flex-1 p-2 bg-indigo-600 rounded text-sm">Register (permissionless)</button>
      </div>
      <div class="mt-3">
        <h4 class="font-semibold">Admin: Set / Upgrade Collection Tier</h4>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mt-2">
          <input id="adminCollAddr" placeholder="Collection address (admin action)" class="p-2 rounded bg-black/20 text-sm" />
          <input id="adminDeclaredSupply" placeholder="Declared supply (uint32)" class="p-2 rounded bg-black/20 text-sm" />
        </div>
        <div class="flex gap-2 mt-2">
          <select id="adminTier" class="p-2 rounded bg-black/20 text-sm">
            <option value="0">UNVERIFIED (0)</option>
            <option value="1">VERIFIED (1)</option>
            <option value="2">BLUECHIP (2)</option>
          </select>
          <button id="adminSetConfigBtn" class="flex-1 p-2 bg-yellow-500 text-black rounded text-sm">Set Collection Config (admin)</button>
        </div>

		  <div class="mt-6 bg-slate-800/50 rounded-2xl shadow-lg p-4 border border-white/10">
  <h4 class="text-lg font-semibold text-white mb-3 flex items-center gap-2">
    ‚öôÔ∏è Admin: Manage Registered Collections
  </h4>

  <!-- Input -->
  <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
    <input 
      id="manageCollAddr" 
      placeholder="Enter collection address" 
      class="p-3 rounded-lg bg-slate-900/60 border border-slate-700/40 text-sm text-white placeholder-slate-400 focus:ring-2 focus:ring-indigo-500 focus:outline-none" 
    />
  </div>

  <!-- Action Buttons -->
  <div class="grid grid-cols-1 md:grid-cols-3 gap-3 mt-4">
    <button 
      id="removeCollectionBtn" 
      class="p-3 rounded-lg bg-red-600 hover:bg-red-700 transition text-sm font-medium shadow-md">
      üóë Remove Collection
    </button>
    <button 
      id="forfeitEscrowBtn" 
      class="p-3 rounded-lg bg-amber-500 hover:bg-amber-600 transition text-sm font-medium text-black shadow-md">
      ‚è≥ Forfeit Escrow
    </button>
    <button 
      id="setBluechipBtn" 
      class="p-3 rounded-lg bg-blue-600 hover:bg-blue-700 transition text-sm font-medium shadow-md">
      üíé Toggle Bluechip
    </button>
  </div>

  <!-- Hint -->
  <p class="mt-3 text-xs text-slate-400">
    * These actions require <span class="font-semibold text-amber-300">admin privileges</span>. 
    Make sure your connected wallet has the proper role.
  </p>
</div>
      </div>
    </section>

    <!-- Bluechip -->
<section id="bluechip" class="tab-content hidden">
  <h2 class="font-semibold mb-2">Bluechip</h2>
  <p class="text-sm text-slate-300 mb-3">
    Enroll as a Bluechip wallet and harvest rewards from Bluechip collections.
  </p>

  <div class="space-y-3 text-sm">
    <!-- Enroll -->
    <div class="flex gap-2">
      <button id="enrollBluechipBtn" class="flex-1 p-2 bg-amber-500 text-black rounded">
        üåü Enroll Bluechip Wallet
      </button>
    </div>

    <!-- Harvest -->
    <div class="grid grid-cols-2 gap-2">
      <input
        id="bluechipCollectionInput"
        placeholder="Bluechip Collection Address"
        class="p-2 rounded bg-black/20"
      />
      <button id="harvestBluechipBtn" class="p-2 bg-sky-600 hover:bg-sky-500 rounded">
        üéÅ Harvest Bluechip
      </button>
    </div>

    <hr class="border-slate-700 my-3" />

    <!-- Wallet Info -->
<h3 class="text-base font-semibold mb-2 text-slate-200 flex items-center gap-2">
  üåü My Bluechip Status
</h3>

<div class="grid grid-cols-2 gap-3 text-center">
  <!-- Enrollment Status -->
  <div class="p-3 rounded-xl bg-slate-800/60 shadow-md">
    <div class="text-slate-400 text-xs">Status</div>
    <div id="bluechipStatus" class="font-bold text-sm text-slate-100">‚Äî</div>
  </div>


  <!-- Last Harvest Block -->
  <div class="p-3 rounded-xl bg-slate-800/60 shadow-md">
    <div class="text-slate-400 text-xs">Last Harvest</div>
    <div id="bluechipLastBlock" class="font-mono text-xs text-indigo-400">‚Äî</div>
  </div>

  <!-- Enrollment Fee -->
  <div class="p-3 rounded-xl bg-slate-800/60 shadow-md">
    <div class="text-slate-400 text-xs">Enrollment Fee</div>
    <div id="bluechipFee" class="font-bold text-sm text-amber-400">‚Äî</div>
  </div>
</div>

<button
  id="refreshBluechipBtn"
  class="mt-3 w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg font-medium text-sm transition"
>
  üîÑ Refresh Bluechip Info
</button>
  </div>
</section>

    <!-- Staking -->
<section id="staking" class="tab-content hidden">
  <h2 class="font-semibold mb-2">Staking</h2>
  <p class="text-sm text-slate-300 mb-3">Approve NFT ‚Üí Term Stake or Permanent Stake ‚Üí Harvest / Unstake</p>
  
  <div class="space-y-2 text-sm">
    <!-- Single NFT Stake -->
    <div class="grid grid-cols-2 gap-2">
      <input id="nftCollection" placeholder="NFT Collection Address" class="p-2 rounded bg-black/20" />
      <input id="nftTokenId" placeholder="Token ID" class="p-2 rounded bg-black/20" />
    </div>
    <div class="flex gap-2">
      <button id="approveNFTBtn" class="flex-1 p-2 bg-yellow-500 text-black rounded">Approve Staking Contract</button>
      <button id="termStakeBtn" class="flex-1 p-2 bg-indigo-600 rounded">Term Stake</button>
    </div>
    <div class="flex gap-2">
      <button id="permApproveFeeBtn" class="flex-1 p-2 bg-amber-600 rounded">Approve Fee (CATA)</button>
      <button id="permStakeBtn" class="flex-1 p-2 bg-emerald-600 text-black rounded">Permanent Stake</button>
    </div>
    <div class="flex gap-2">
      <button id="harvestBtn" class="flex-1 p-2 bg-sky-600 rounded">Harvest</button>
      <button id="unstakeBtn" class="flex-1 p-2 bg-red-600 rounded">Unstake</button>
    </div>

    <hr class="border-slate-700 my-2" />

    <!-- Batch Staking -->
    <h3 class="text-sm font-semibold mb-1">Batch Operations</h3>
    <textarea id="batchNFTs" placeholder="collection,tokenId per line" class="w-full p-2 rounded bg-black/20 text-sm h-28 font-mono"></textarea>
    <div class="flex gap-2 mt-2">
      <button id="batchTermStakeBtn" class="flex-1 p-2 bg-indigo-500 rounded text-sm">Batch Term Stake</button>
      <button id="batchPermStakeBtn" class="flex-1 p-2 bg-emerald-500 rounded text-sm">Batch Permanent Stake</button>
      <button id="batchUnstakeBtn" class="flex-1 p-2 bg-red-500 rounded text-sm">Batch Unstake</button>
    </div>

    <hr class="border-slate-700 my-2" />

    <!-- Batch Harvest -->
    <h3 class="text-sm font-semibold mb-1">Batch Harvest</h3>
    <textarea id="batchHarvestNFTs" placeholder="collection,tokenId per line" class="w-full p-2 rounded bg-black/20 text-sm h-28 font-mono"></textarea>
    <div class="flex gap-2 mt-2">
      <button id="batchHarvestBtn" class="flex-1 p-2 bg-sky-600 rounded text-sm">Batch Harvest</button>
    </div>

    <hr class="border-slate-700 my-2" />

    <!-- Extra Features -->
<h3 class="text-base font-semibold mb-2 text-slate-200 flex items-center gap-2">
  ‚ö° Other Actions
</h3>
<div class="grid gap-3 sm:grid-cols-2">
  <!-- Pending Rewards -->
  <div class="p-3 rounded-xl bg-gradient-to-r from-slate-800 to-slate-900 shadow-md">
    <button id="pendingRewardsBtn" class="w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium transition">
      üéÅ Check Pending Rewards
    </button>
    <div id="pendingRewardsResult" class="mt-2 text-xs text-slate-300 font-mono">‚Äî</div>
  </div>

  <!-- Portfolio -->
  <div class="p-3 rounded-xl bg-gradient-to-r from-slate-800 to-slate-900 shadow-md">
    <button id="viewPortfolioBtn" class="w-full p-2 bg-indigo-600 hover:bg-indigo-500 rounded-lg text-sm font-medium transition">
      üìÇ View My Staked NFTs
    </button>
    <div id="portfolioResult" class="mt-2 text-xs text-slate-300 font-mono break-all">‚Äî</div>
  </div>
</div>

<hr class="border-slate-700 my-4" />

<!-- Staking Stats -->
<h3 class="text-base font-semibold mb-2 text-slate-200 flex items-center gap-2">
  üìä Staking Stats
</h3>
<div class="grid grid-cols-3 gap-3 text-center">
  <div class="p-3 rounded-lg bg-slate-800/60 shadow">
    <div class="text-slate-400 text-xs">Total</div>
    <div id="stakedAll" class="font-bold text-lg text-slate-100">‚Äî</div>
  </div>
  <div class="p-3 rounded-lg bg-slate-800/60 shadow">
    <div class="text-slate-400 text-xs">Term</div>
    <div id="stakedTerm" class="font-bold text-lg text-indigo-400">‚Äî</div>
  </div>
  <div class="p-3 rounded-lg bg-slate-800/60 shadow">
    <div class="text-slate-400 text-xs">Perm</div>
    <div id="stakedPerm" class="font-bold text-lg text-emerald-400">‚Äî</div>
  </div>
</div>
<button id="refreshStakingStatsBtn" class="mt-3 w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium transition">
  üîÑ Refresh Staking Stats
</button>
  </div>
</section>

<!-- Governance -->
<section id="governance" class="tab-content hidden">
  <h2 class="font-semibold mb-2">Governance DAO</h2>
  <p class="text-sm text-slate-300 mb-3">
    Create proposals, vote, execute them, and monitor governance activity.
  </p>

  <!-- Proposal Creator -->
  <div class="glass p-4 rounded-lg space-y-3">
    <h3 class="font-semibold">Create Proposal</h3>

    <!-- Proposal type -->
    <select id="proposalType" class="w-full p-2 rounded bg-black/20 text-sm">
      <optgroup label="üìä Protocol Parameters">
        <option value="BASE_REWARD">Base Reward</option>
        <option value="HARVEST_FEE">Harvest Fee</option>
        <option value="UNSTAKE_FEE">Unstake Fee</option>
        <option value="REGISTRATION_FEE_FALLBACK">Registration Fee Fallback</option>
        <option value="VOTING_PARAM">Voting Parameter</option>
        <option value="TIER_UPGRADE">Tier Upgrade</option>
      </optgroup>

      <optgroup label="üõ° Guardian Council Ops">
        <option value="COUNCIL_RESEED_ACTIVE">Reseed Guardians (Active)</option>
        <option value="COUNCIL_PROPOSE_STANDBY">Propose Guardians (Standby)</option>
        <option value="COUNCIL_COMMIT_STANDBY">Commit Guardians (Standby)</option>
        <option value="COUNCIL_ACTIVATE_STANDBY">Activate Guardians (Standby)</option>
        <option value="COUNCIL_PROPOSE_NEW_DAO">Propose New DAO</option>
        <option value="COUNCIL_COMMIT_NEW_DAO">Commit New DAO</option>
        <option value="COUNCIL_CLEAR_LOCK">Clear Lock/Warning</option>
        <option value="UPGRADE_COUNCIL">Upgrade Council Implementation</option>
      </optgroup>
    </select>

	  <!-- single create button -->
    <button id="createProposalBtn" class="w-full p-2 bg-violet-600 rounded">Create Proposal</button>
  </div> <!-- end Proposal Creator card -->

    <!-- Generic proposal fields (must be inside the card) -->
    <input id="proposalValue" placeholder="New numeric value" class="w-full p-2 rounded bg-black/20 text-sm" />
    <input id="proposalCollectionCtx" placeholder="Collection context (optional)" class="w-full p-2 rounded bg-black/20 text-sm" />
    <input id="paramTarget" placeholder="paramTarget (for VotingParam/TierUpgrade)" class="w-full p-2 rounded bg-black/20 text-sm" />

    <!-- Tier Upgrade fields -->
    <div id="tierUpgradeRow" class="grid grid-cols-1 md:grid-cols-3 gap-2 hidden">
      <select id="tierTo" class="p-2 rounded bg-black/20 text-sm">
        <option value="0">UNVERIFIED (0)</option>
        <option value="1">VERIFIED (1)</option>
        <option value="2">BLUECHIP (2)</option>
      </select>
      <input id="tierCollection" placeholder="Collection address" class="p-2 rounded bg-black/20 text-sm" />
      <input id="tierDeclaredSupply" placeholder="Declared supply (uint32)" class="p-2 rounded bg-black/20 text-sm" />
    </div>

    <!-- Council batch reseed fields -->
    <div id="councilBatchRow" class="hidden space-y-2">
      <p class="text-xs text-slate-400">Enter 7 guardian addresses for new batch:</p>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 1" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 2" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 3" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 4" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 5" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 6" />
        <input class="councilAddr p-2 rounded bg-black/20 text-sm" placeholder="Guardian 7" />
      </div>
    </div> <!-- <-- important: close councilBatchRow here -->

    <!-- Propose new DAO -->
    <div id="newDaoRow" class="hidden">
      <input id="newDaoAddr" placeholder="New DAO address" class="w-full p-2 rounded bg-black/20 text-sm" />
    </div>

    <!-- Upgrade council -->
    <div id="upgradeCouncilRow" class="hidden">
      <input id="newCouncilImpl" placeholder="New council implementation address" class="w-full p-2 rounded bg-black/20 text-sm" />
    </div>

  <!-- Voting / Execution -->
  <div class="glass p-4 rounded-lg space-y-3 mt-4">
    <h3 class="font-semibold">Vote & Execute</h3>

    <input id="proposalId" placeholder="Proposal ID (hex)" class="w-full p-2 rounded bg-black/20 text-sm" />
    <div class="flex gap-2">
      <button id="voteProposalBtn" class="flex-1 p-2 bg-blue-600 rounded">Vote</button>
      <button id="execProposalBtn" class="flex-1 p-2 bg-green-700 rounded">Execute</button>
    </div>
    <button id="fetchProposalBtn" class="w-full p-2 bg-slate-600 rounded">Fetch Proposal Details</button>
  </div>

  <!-- Proposals Explorer -->
  <div class="glass p-4 rounded-lg mt-4">
    <h3 class="font-semibold mb-2">Proposals Explorer</h3>
    <div class="overflow-x-auto">
      <table class="w-full text-sm">
        <thead class="text-xs text-slate-400">
          <tr>
            <th class="p-2">ID</th>
            <th class="p-2">Type</th>
            <th class="p-2">Value</th>
            <th class="p-2">Context</th>
            <th class="p-2">Proposer</th>
            <th class="p-2">Votes</th>
            <th class="p-2">Executed</th>
            <th class="p-2">Action</th>
          </tr>
        </thead>
        <tbody id="proposalsTbody"></tbody>
      </table>
    </div>
  </div>
</section>

<section id="council" class="tab-content hidden">
  <h2 class="font-semibold mb-2">DRS Guardian Council</h2>
  <p class="text-sm text-slate-300 mb-3">
    Manage guardian batches, DAO rotation, and emergency recovery.
  </p>

  <!-- DAO -->
  <div class="space-y-2 text-sm">
    <div class="grid grid-cols-2 gap-2">
      <input id="newDaoAddr" placeholder="New DAO address" class="p-2 rounded bg-black/20" />
      <button id="proposeDaoBtn" class="p-2 bg-indigo-600 rounded">Propose DAO</button>
    </div>
    <button id="commitDaoBtn" class="w-full p-2 bg-indigo-400 rounded">Commit DAO</button>
  </div>

  <hr class="border-slate-700 my-2" />

  <!-- Active Batch -->
  <div class="space-y-2 text-sm">
    <textarea id="activeBatchInput" placeholder="7 addresses, one per line"
      class="w-full p-2 rounded bg-black/20 h-28 font-mono"></textarea>
    <div class="flex gap-2">
      <button id="proposeActiveBatchBtn" class="flex-1 p-2 bg-amber-600 rounded">Propose Active Batch</button>
      <button id="commitActiveBatchBtn" class="flex-1 p-2 bg-amber-400 rounded">Commit Active Batch</button>
    </div>
  </div>

  <!-- Standby Batch -->
  <div class="space-y-2 text-sm mt-3">
    <textarea id="standbyBatchInput" placeholder="7 addresses, one per line"
      class="w-full p-2 rounded bg-black/20 h-28 font-mono"></textarea>
    <div class="flex gap-2">
      <button id="proposeStandbyBatchBtn" class="flex-1 p-2 bg-emerald-600 rounded">Propose Standby Batch</button>
      <button id="commitStandbyBatchBtn" class="flex-1 p-2 bg-emerald-400 rounded">Commit Standby Batch</button>
    </div>
    <button id="activateStandbyBtn" class="w-full p-2 bg-green-600 rounded mt-2">Activate Standby</button>
  </div>

  <hr class="border-slate-700 my-2" />

  <!-- Lock & Warning -->
  <div class="space-y-2 text-sm">
    <button id="clearLockBtn" class="w-full p-2 bg-slate-600 rounded">Clear Lock/Warning</button>
  </div>

  <hr class="border-slate-700 my-2" />

<!-- Recovery -->
<h3 class="text-sm font-semibold mb-1">Recovery Request</h3>
<div class="space-y-2 text-sm">
  <!-- Kind -->
  <select id="recoveryKind" class="w-full p-2 rounded bg-black/20">
    <option value="0">Deployer</option>
    <option value="1">Admin</option>
  </select>

  <!-- Inputs -->
  <input id="recoveryProposed" placeholder="Proposed address" class="w-full p-2 rounded bg-black/20" />
  <input id="recoveryCallTarget" placeholder="Target contract address" class="w-full p-2 rounded bg-black/20" />

  <!-- ABI encoding helper -->
  <input id="recoveryFunction" placeholder="Function (e.g. upgradeTo(address))" class="w-full p-2 rounded bg-black/20" />
  <input id="recoveryArgs" placeholder="Arguments (comma-separated)" class="w-full p-2 rounded bg-black/20" />

  <!-- Auto-generated -->
  <textarea id="recoveryCallData" placeholder="Calldata (auto-generated 0x...)" class="w-full p-2 rounded bg-black/20 font-mono h-20"></textarea>
  <button id="encodeCallDataBtn" class="w-full p-2 bg-blue-600 rounded">Encode CallData</button>

  <!-- Buttons -->
  <div class="flex gap-2 mt-2">
    <button id="proposeRecoveryBtn" class="flex-1 p-2 bg-red-600 rounded">Propose Recovery</button>
    <button id="approveRecoveryBtn" class="flex-1 p-2 bg-orange-600 rounded">Approve</button>
    <button id="executeRecoveryBtn" class="flex-1 p-2 bg-green-600 rounded">Execute</button>
    <button id="vetoRecoveryBtn" class="flex-1 p-2 bg-slate-600 rounded">Veto</button>
  </div>

	<hr class="border-slate-700 my-3" />

<!-- Recovery Info Panel -->
<div id="recoveryInfo" class="p-4 rounded-xl bg-slate-800/40 border border-slate-700 shadow-sm text-sm space-y-2">
  <h4 class="font-semibold text-slate-100 text-base">üìä Recovery Status</h4>
  <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-1">
    <p><span class="text-slate-400">Proposed:</span> <span id="riProposed" class="font-medium text-slate-200">-</span></p>
    <p><span class="text-slate-400">Approvals:</span> <span id="riApprovals" class="font-medium text-slate-200">-</span></p>
    <p><span class="text-slate-400">Deadline:</span> <span id="riDeadline" class="font-medium text-slate-200">-</span></p>
    <p><span class="text-slate-400">Executed:</span> <span id="riExecuted" class="font-medium">-</span></p>
    <p><span class="text-slate-400">Call Target:</span> <span id="riCallTarget" class="font-mono text-xs text-slate-300">-</span></p>
    <p><span class="text-slate-400">Call Data:</span> <span id="riCallData" class="font-mono text-xs text-slate-300 break-all">-</span></p>
    <p><span class="text-slate-400">Guardian:</span> <span id="riGuardian" class="font-medium text-slate-200">-</span></p>
    <p><span class="text-slate-400">Veto Expiry:</span> <span id="riVetoExpiry" class="font-medium text-slate-200">-</span></p>
  </div>

  <!-- Selector -->
  <div class="mt-3">
    <label for="recoveryKind" class="block text-slate-300 text-sm font-medium mb-1">Recovery Kind</label>
    <select id="recoveryKind" class="w-full p-2 rounded-lg bg-slate-900 text-slate-200 border border-slate-700">
      <option value="0">Deployer</option>
      <option value="1">Admin</option>
    </select>
  </div>

  <button id="refreshRecoveryBtn" class="mt-3 w-full p-2 bg-slate-700 hover:bg-slate-600 rounded-lg font-semibold text-white transition">
    üîÑ Refresh Recovery Info
  </button>
</div>
</div>
</section>

	  <div id="whitepaper" class="tab-content hidden">
  <div class="glass ring-1 rounded-2xl p-5 space-y-6">
    <h2 class="text-xl font-semibold">Whitepaper Summary</h2>

    <!-- Vision & Mission -->
    <details class="glass ring-1 rounded-lg p-4" open>
      <summary class="cursor-pointer font-medium text-slate-200">
        Vision &amp; Mission
      </summary>
      <p class="text-slate-300 text-sm mt-2 leading-relaxed">
        Catalyst aims to be the universal utility layer for NFTs: every ERC-721 can stake, burn, 
        and participate in governance. The protocol balances incentives between blue-chip collections, 
        verified custodial projects, and unverified projects ‚Äî using proof-of-burn and escrow 
        forfeits for legitimacy.
      </p>
    </details>

    <!-- Tokenomics -->
    <details class="glass ring-1 rounded-lg p-4">
      <summary class="cursor-pointer font-medium text-slate-200">
        Tokenomics (CATA)
      </summary>
      <ul class="mt-2 text-sm text-slate-300 list-disc ml-5 space-y-1">
        <li>Immutable fee split: <span class="mono">90% Burn / 9% Treasury / 1% Deployer</span></li>
        <li>Global stake cap: <span class="mono">500M NFTs</span> (375M term, 125M permanent)</li>
        <li>Per-collection cap: <span class="mono">20k NFTs</span></li>
        <li>Token max supply: <span class="mono">1B CATA</span> (100M premint to initial admin)</li>
        <li>Minting restricted to <span class="mono">CatalystStaking</span></li>
      </ul>
    </details>

    <!-- Governance -->
    <details class="glass ring-1 rounded-lg p-4">
      <summary class="cursor-pointer font-medium text-slate-200">
        Governance
      </summary>
      <p class="text-slate-300 text-sm mt-2 leading-relaxed">
        Burn-weighted voting with per-collection caps and stake-based weighting. 
        Proposals may adjust reward rates, fees, tiers, and reseed Guardian Council batches. 
        The <span class="mono">90 / 9 / 1</span> split is immutable by governance.
      </p>
    </details>

    <!-- Guardian Recovery -->
    <details class="glass ring-1 rounded-lg p-4">
      <summary class="cursor-pointer font-medium text-slate-200">
        Guardian Recovery (Batch Guardian Council)
      </summary>
      <p class="text-slate-300 text-sm mt-2 leading-relaxed">
        The Batch Guardian Council secures upgrades and recovery. Two rotating batches of 7 guardians 
        ensure failover. Recovery requires 5-of-7 approvals, 6-of-7 triggers a warning with a 
        48h Last Honest veto, and 7-of-7 forces auto-lock with standby activation.
      </p>
    </details>

    <div class="text-xs text-slate-400">
      Read the full paper for detailed math, proofs, and edge cases.
    </div>
  </div>
</div>
</div>
</main>

    <section class="glass p-4 rounded-lg mt-6">
      <h3 class="font-semibold mb-2">Advanced / Logs</h3>
      <div id="logs" class="h-48 overflow-auto text-xs font-mono bg-black/20 p-3 rounded"></div>
    </section>

    <footer class="mt-6 text-xs text-slate-500 text-center">
  ¬© Catalyst Protocol ‚Äî Decentralized &amp; Community-Governed.<br />
  <span class="block mt-1">All contracts are upgradeable via DAO &amp; Batch Guardian Council. Use at your own risk.</span>
</footer>
  </div>

  <!-- load ethers first -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>

  <script>
  /************************************************************************
   * DApp main - dynamic ABI loading + wiring for CATA / Staking /
   * Governance / GuardianCouncil. Uses your uploaded contracts as spec.
   *
   * Note: ABIs must be provided at the ABI_URLS paths (json ABI files).
   * Put e.g. /abi/CataERC20Upgradeable.json, /abi/CatalystStakingUpgradeable.json, etc.
   ************************************************************************/

  // ---------- ABI URLs (external ABI JSONs) ----------
  const ABI_URLS = {
    cata: "../abi/CataERC20Upgradeable.json",
    staking: "../abi/CatalystStakingUpgradeable.json",
    governance: "../abi/CatalystGovernanceUpgradeable.json",
    council: "../abi/BatchGuardianCouncilUpgradeable.json"
  };

  // Minimal ERC-721 ABI kept inline (approval helpers)
  const ERC721_ABI = [
    'function approve(address to, uint256 tokenId)',
    'function setApprovalForAll(address operator, bool approved)',
    'function isApprovedForAll(address owner, address operator) view returns (bool)'
  ];

  // Default addresses (replace with your deployed addresses)
  const DEFAULT_ADDRS = {
    cata: "0x1234567890abcdef1234567890abcdef12345678",
    staking: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd",
    governance: "0x9876543210abcdef9876543210abcdef98765432",
    council: "0xfeedfeedfeedfeedfeedfeedfeedfeedfeedfeed"
  };

  // App state
  let provider = null, signer = null, userAddr = null;
  let abis = {}, contracts = { cata:null, staking:null, governance:null, council:null };

  const $ = id => document.getElementById(id);
  function log(...args){
    const el = $('logs');
    try {
      el.innerText = new Date().toISOString() + ' ‚Ä¢ ' + args.map(a=>typeof a==='object'?JSON.stringify(a):a).join(' ') + '\n' + el.innerText;
    } catch(e) { console.log(...args); }
    console.log(...args);
  }

  // Fetch JSON with error handling
  async function fetchJSON(path){
    try {
      const res = await fetch(path);
      if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
      return await res.json();
    } catch (e) {
      log('fetchJSON err', path, e.message || e);
      return null;
    }
  }

  // Load ABIs from ABI_URLS
  async function loadABIs(){
    for(const k of Object.keys(ABI_URLS)){
      const j = await fetchJSON(ABI_URLS[k]);
      abis[k] = j; // null if failed
    }
    log('ABIs loaded', Object.keys(abis).map(k => `${k}:${abis[k]? 'ok':'missing'}`).join(' '));
  }

  // Save/load addresses to localStorage
  function saveAddrsToLocal(payload){
    try {
      localStorage.setItem('catalyst_addrs', JSON.stringify(payload));
      log('Saved addresses');
    } catch(e){ log('saveAddrs err', e); }
  }

  function loadSavedAddrs(){
    try {
      const raw = localStorage.getItem('catalyst_addrs');
      if(!raw){
        // prefill defaults
        $('addrCata').value = DEFAULT_ADDRS.cata;
        $('addrStaking').value = DEFAULT_ADDRS.staking;
        $('addrGovernance').value = DEFAULT_ADDRS.governance;
        $('addrCouncil').value = DEFAULT_ADDRS.council;
        log('Prefilled default addresses');
        return;
      }
      const obj = JSON.parse(raw);
      if(obj.addrCata) $('addrCata').value = obj.addrCata;
      if(obj.addrStaking) $('addrStaking').value = obj.addrStaking;
      if(obj.addrGovernance) $('addrGovernance').value = obj.addrGovernance;
      if(obj.addrCouncil) $('addrCouncil').value = obj.addrCouncil;
      log('Loaded saved addresses');
    } catch(e){ log('loadSavedAddrs err', e); }
  }

  // Attach contract instances (requires signer)
  async function attachContractsIfSet(){
    try {
      if(!provider || !signer) return;
      // ensure ABIs present (attempt load if missing)
      if(Object.keys(abis).length === 0 || Object.values(abis).every(v => v == null)) {
        await loadABIs();
      }
      const cataA = $('addrCata').value.trim();
      const stakingA = $('addrStaking').value.trim();
      const govA = $('addrGovernance').value.trim();
      const councilA = $('addrCouncil').value.trim();

      if(cataA && abis.cata) contracts.cata = new ethers.Contract(cataA, abis.cata, signer);
      else contracts.cata = null;

      if(stakingA && abis.staking) contracts.staking = new ethers.Contract(stakingA, abis.staking, signer);
      else contracts.staking = null;

      if(govA && abis.governance) contracts.governance = new ethers.Contract(govA, abis.governance, signer);
      else contracts.governance = null;

      if(councilA && abis.council) contracts.council = new ethers.Contract(councilA, abis.council, signer);
      else contracts.council = null;

      log('Contracts attached', {
        cata: !!contracts.cata,
        staking: !!contracts.staking,
        governance: !!contracts.governance,
        council: !!contracts.council
      });

      // fetch balances if available
      if(contracts.cata) await fetchCataBalance();
    } catch(e){ log('attachContractsIfSet err', e && e.message ? e.message : e); }
  }

  async function fetchCataBalance(){
    try {
      if(!contracts.cata) return;
      const bal = await contracts.cata.balanceOf(userAddr);
      $('cataBal').innerText = ethers.utils.formatEther(bal) + ' CATA';
    } catch(e){ log('fetchCataBalance err', e && e.message ? e.message : e); }
  }

  // ---------- Connect / Disconnect ----------
  async function connect(){
    try {
      if(!window.ethereum) return alert('No Web3 wallet (install MetaMask)');
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send('eth_requestAccounts', []);
      signer = provider.getSigner();
      userAddr = await signer.getAddress();
      $('addr').innerText = userAddr;
      const net = await provider.getNetwork();
      $('networkName').innerText = net.name + ' (' + net.chainId + ')';
      $('connectBtn').classList.add('hidden');
      $('disconnectBtn').classList.remove('hidden');

      // load ABIs & attach
      await loadABIs();
      await attachContractsIfSet();
      log('Connected', userAddr);
    } catch(e){ log('connect err', e && e.message ? e.message : e); }
  }

  function disconnect(){
    provider = signer = userAddr = null;
    contracts = { cata:null, staking:null, governance:null, council:null };
    $('addr').innerText = 'Not connected';
    $('networkName').innerText = '‚Äî';
    $('cataBal').innerText = '‚Äî';
    $('connectBtn').classList.remove('hidden');
    $('disconnectBtn').classList.add('hidden');
    log('Disconnected');
  }

  // ---------- CATA functions ----------
  async function cataMint(){
    try {
      if(!contracts.cata) { await attachContractsIfSet(); if(!contracts.cata) return alert('Set CATA contract address'); }
      const to = $('cataMintTo').value.trim();
      const amtRaw = $('cataMintAmt').value.trim();
      if(!to || !amtRaw) return alert('mint: to & amount required');
      // keep amount as string to avoid precision issues; contract expects uint256 (wei)
      const tx = await contracts.cata.mint(to, ethers.BigNumber.from(amtRaw));
      log('cata.mint tx', tx.hash);
      await tx.wait();
      log('cata.mint completed');
      await fetchCataBalance();
    } catch(e){ log('cataMint err', e && e.message ? e.message : e); }
  }

  async function cataBurn(){
    try {
      if(!contracts.cata) { await attachContractsIfSet(); if(!contracts.cata) return alert('Set CATA contract address'); }
      const amtRaw = $('cataMintAmt').value.trim(); // reuse input for burn amount (UI convenience)
      if(!amtRaw) return alert('burn: amount required');
      const tx = await contracts.cata.burn(ethers.BigNumber.from(amtRaw));
      log('cata.burn tx', tx.hash);
      await tx.wait();
      log('cata.burn completed');
      await fetchCataBalance();
    } catch(e){ log('cataBurn err', e && e.message ? e.message : e); }
  }

  async function cataSwapAdmin(){
    try {
      if(!contracts.cata) { await attachContractsIfSet(); if(!contracts.cata) return alert('Set CATA contract address'); }
      const newAdmin = $('swapNewAdmin').value.trim();
      const oldAdmin = $('swapOldAdmin').value.trim() || ethers.constants.AddressZero;
      if(!newAdmin) return alert('new admin required');
      // only callable by guardian council per contract; it will revert if caller not council
      const tx = await contracts.cata.swapAdmin(newAdmin, oldAdmin);
      log('cata.swapAdmin tx', tx.hash);
      await tx.wait();
      log('cata.swapAdmin completed');
    } catch(e){ log('cataSwapAdmin err', e && e.message ? e.message : e); }
  }

/********************************************************************
 * Collection Registration logic
 ********************************************************************/
// ---------- Minimal ERC20 ABI fallback (allowance/approve) ----------
const MIN_ERC20_ABI = [
  'function allowance(address owner, address spender) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)'
];

// BigNumber helpers & fee constants (match contract constants)
const ONE = ethers.BigNumber.from("1000000000000000000");
const SMALL_MIN_FEE = ONE.mul(1);
const SMALL_MAX_FEE = ONE.mul(10);
const MED_MIN_FEE = ONE.mul(11);
const MED_MAX_FEE = ONE.mul(50);
const LARGE_MIN_FEE = ONE.mul(51);
const LARGE_MAX_FEE_CAP = ONE.mul(200);
const BP_DENOM = 10000;

/** calculate baseFee using same curve logic as the contract (BigNumber safe) */
function calculateRegistrationBaseFeeBN(declaredSupplyInt) {
  if (!Number.isInteger(declaredSupplyInt) || declaredSupplyInt < 1) {
    throw new Error('declaredSupply must be integer >= 1');
  }
  const dsBN = ethers.BigNumber.from(String(declaredSupplyInt));
  if (declaredSupplyInt <= 5000) {
    const numer = dsBN.mul(SMALL_MAX_FEE.sub(SMALL_MIN_FEE));
    return SMALL_MIN_FEE.add(numer.div(5000));
  } else if (declaredSupplyInt <= 10000) {
    const numer = dsBN.sub(5000).mul(MED_MAX_FEE.sub(MED_MIN_FEE));
    return MED_MIN_FEE.add(numer.div(5000));
  } else {
    const extra = declaredSupplyInt - 10000;
    const range = 10000;
    if (extra >= range) return LARGE_MAX_FEE_CAP;
    const numer = ethers.BigNumber.from(String(extra)).mul(LARGE_MAX_FEE_CAP.sub(LARGE_MIN_FEE));
    return LARGE_MIN_FEE.add(numer.div(range));
  }
}

/** compute total fee (baseFeeBN) for tier (uint8). reads unverified surcharge BP from contract if needed */
async function computeTotalFeeBN(baseFeeBN, tier) {
  let multBP = BP_DENOM; // default (no surcharge)
  try {
    if (tier === 0) {
      // try reading from contract (public variable)
      if (contracts.staking && typeof contracts.staking.unverifiedSurchargeBP === 'function') {
        const bp = await contracts.staking.unverifiedSurchargeBP();
        multBP = bp.toNumber(); // fall back if fails
      } else {
        // fallback default used in your code
        multBP = 12000;
      }
    }
  } catch (e) {
    log('computeTotalFeeBN: could not read unverifiedSurchargeBP, using fallback 12000', e);
    if (tier === 0) multBP = 12000;
  }
  const total = baseFeeBN.mul(ethers.BigNumber.from(String(multBP))).div(ethers.BigNumber.from(String(BP_DENOM)));
  const surcharge = total.gt(baseFeeBN) ? total.sub(baseFeeBN) : ethers.BigNumber.from("0");
  return { totalFeeBN: total, surchargeBN: surcharge, multBP };
}

/** Format BigNumber wei to readable Ether string */
function fmtCata(bn) { return ethers.utils.formatEther(bn) + ' CATA'; }

/** Ensure we have an ERC20 contract instance for CATA (ABI might be in abis.cata or fallback) */
function getCataERC20ContractInstance() {
  const cataAddr = $('addrCata').value.trim();
  if (!cataAddr) throw new Error('CATA address not set in UI');
  if (contracts.cata && typeof contracts.cata.allowance === 'function') return contracts.cata;
  // fallback to minimal ABI
  return new ethers.Contract(cataAddr, MIN_ERC20_ABI, signer);
}

/** Calculate fee and update UI */
async function handleCalcRegFee() {
  try {
    const supplyStr = $('regDeclaredSupply').value.trim();
    const collection = $('regCollectionAddr').value.trim();
    if (!supplyStr || !collection) return alert('collection and declared supply required for fee calc');
    const declaredSupply = parseInt(supplyStr, 10);
    const baseFeeBN = calculateRegistrationBaseFeeBN(declaredSupply);
    const tier = parseInt($('regTier').value, 10);
    const { totalFeeBN, surchargeBN, multBP } = await computeTotalFeeBN(baseFeeBN, tier);
    $('regFeeInfo').innerText = `Base: ${fmtCata(baseFeeBN)}  |  SurchargeBP: ${multBP}  |  Total: ${fmtCata(totalFeeBN)}  |  Surcharge: ${fmtCata(surchargeBN)}`;
    return { baseFeeBN, totalFeeBN, surchargeBN };
  } catch (e) {
    log('handleCalcRegFee err', e && e.message ? e.message : e);
    alert('Fee calc error: ' + (e.message || e));
  }
}

/** Approve CATA to staking contract for registration (amount param optional ‚Äî will use computed fee if available) */
async function handleApproveForRegistration() {
  try {
    if (!provider || !signer) return alert('connect wallet first');
    const stakingAddr = $('addrStaking').value.trim();
    if (!stakingAddr) return alert('set staking address first');
    // compute fee
    const supplyStr = $('regDeclaredSupply').value.trim();
    const declaredSupply = parseInt(supplyStr, 10);
    if (!supplyStr || isNaN(declaredSupply)) return alert('enter declared supply to compute fee before approving');
    const baseFeeBN = calculateRegistrationBaseFeeBN(declaredSupply);
    const tier = parseInt($('regTier').value, 10);
    const { totalFeeBN } = await computeTotalFeeBN(baseFeeBN, tier);
    const cata = getCataERC20ContractInstance();
    const tx = await cata.approve(stakingAddr, totalFeeBN);
    log('approve tx', tx.hash);
    await tx.wait();
    log('approve completed for', fmtCata(totalFeeBN));
  } catch (e) {
    log('handleApproveForRegistration err', e && e.message ? e.message : e);
    alert('Approve failed: ' + (e.message || e));
  }
}

/** Permissionless registration: approve if needed, then call registerCollection(collection, declaredSupply, tier) */
async function handleRegisterCollection() {
  try {
    if (!provider || !signer) return alert('connect wallet first');
    const collection = $('regCollectionAddr').value.trim();
    const supplyStr = $('regDeclaredSupply').value.trim();
    if (!collection || !supplyStr) return alert('collection & declared supply required');
    const declaredSupply = parseInt(supplyStr, 10);
    const tier = parseInt($('regTier').value, 10);

    // compute fee
    const baseFeeBN = calculateRegistrationBaseFeeBN(declaredSupply);
    const { totalFeeBN } = await computeTotalFeeBN(baseFeeBN, tier);

    // ensure allowance
    const cata = getCataERC20ContractInstance();
    const myAddr = await signer.getAddress();
    const stakingAddr = $('addrStaking').value.trim();
    if (!stakingAddr) return alert('Set staking contract address first');

    const allowance = await cata.allowance(myAddr, stakingAddr);
    if (allowance.lt(totalFeeBN)) {
      const ok = confirm('You need to approve CATA for the registration fee: ' + fmtCata(totalFeeBN) + '. Approve now?');
      if (!ok) return;
      const txA = await cata.approve(stakingAddr, totalFeeBN);
      log('approve tx', txA.hash);
      await txA.wait();
      log('approve done');
    }

    // call registerCollection(collection, declaredSupply, tier)
    if (!contracts.staking || typeof contracts.staking.registerCollection !== 'function') {
      // try attaching if ABI missing
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.registerCollection !== 'function') {
        return alert('staking contract ABI missing registerCollection function or contract not attached');
      }
    }

    const tx = await contracts.staking.registerCollection(collection, declaredSupply, tier);
    log('registerCollection tx', tx.hash);
    await tx.wait();
    log('registerCollection completed ‚Äî watch CollectionAdded event for details');
  } catch (e) {
    log('handleRegisterCollection err', e && e.message ? e.message : e);
    alert('Register failed: ' + (e.message || e));
  }
}

/** Admin: setCollectionConfig(collection, declaredMaxSupply, tier) ‚Äî will revert if caller not admin */
async function handleAdminSetCollectionConfig() {
  try {
    if (!provider || !signer) return alert('connect wallet first');
    if (!contracts.staking || typeof contracts.staking.setCollectionConfig !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.setCollectionConfig !== 'function') {
        return alert('staking contract ABI missing setCollectionConfig or contract not attached');
      }
    }
    const collection = $('adminCollAddr').value.trim();
    const declaredSupply = parseInt($('adminDeclaredSupply').value.trim(), 10);
    const tier = parseInt($('adminTier').value, 10);
    if (!collection || !declaredSupply) return alert('collection & declared supply required');
    const tx = await contracts.staking.setCollectionConfig(collection, declaredSupply, tier);
    log('setCollectionConfig tx', tx.hash);
    await tx.wait();
    log('setCollectionConfig completed (admin)');
  } catch (e) {
    log('handleAdminSetCollectionConfig err', e && e.message ? e.message : e);
    alert('Admin set failed: ' + (e.message || e));
  }
}

	  /********************************************************************
 * Extra Collection Management (Admin)
 ********************************************************************/

/** Admin: removeCollection(collection) */
async function handleRemoveCollection() {
  try {
    if (!provider || !signer) return alert('connect wallet first');
    if (!contracts.staking || typeof contracts.staking.removeCollection !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.removeCollection !== 'function') {
        return alert('staking contract ABI missing removeCollection or not attached');
      }
    }
    const collection = $('manageCollAddr').value.trim();
    if (!collection) return alert('collection required');
    const tx = await contracts.staking.removeCollection(collection);
    log('removeCollection tx', tx.hash);
    await tx.wait();
    log('Collection removed:', collection);
  } catch (e) {
    log('handleRemoveCollection err', e && e.message ? e.message : e);
    alert('Remove failed: ' + (e.message || e));
  }
}

/** Admin: forfeitEscrowIfExpired(collection) */
async function handleForfeitEscrow() {
  try {
    if (!provider || !signer) return alert('connect wallet first');
    if (!contracts.staking || typeof contracts.staking.forfeitEscrowIfExpired !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.forfeitEscrowIfExpired !== 'function') {
        return alert('staking contract ABI missing forfeitEscrowIfExpired or not attached');
      }
    }
    const collection = $('manageCollAddr').value.trim();
    if (!collection) return alert('collection required');
    const tx = await contracts.staking.forfeitEscrowIfExpired(collection);
    log('forfeitEscrowIfExpired tx', tx.hash);
    await tx.wait();
    log('Escrow forfeited for:', collection);
  } catch (e) {
    log('handleForfeitEscrow err', e && e.message ? e.message : e);
    alert('Forfeit failed: ' + (e.message || e));
  }
}

/** Admin: setBluechipCollection(collection, bool) */
async function handleToggleBluechip() {
  try {
    if (!provider || !signer) return alert('connect wallet first');
    if (!contracts.staking || typeof contracts.staking.setBluechipCollection !== 'function') {
      await attachContractsIfSet();
      if (!contracts.staking || typeof contracts.staking.setBluechipCollection !== 'function') {
        return alert('staking contract ABI missing setBluechipCollection or not attached');
      }
    }
    const collection = $('manageCollAddr').value.trim();
    if (!collection) return alert('collection required');

    // Check current status if function available
    let newStatus = true;
    if (typeof contracts.staking.isBluechipCollection === 'function') {
      const current = await contracts.staking.isBluechipCollection(collection);
      newStatus = !current;
    }

    const tx = await contracts.staking.setBluechipCollection(collection, newStatus);
    log('setBluechipCollection tx', tx.hash);
    await tx.wait();
    log('Bluechip status updated:', collection, '=>', newStatus);
  } catch (e) {
    log('handleToggleBluechip err', e && e.message ? e.message : e);
    alert('Bluechip toggle failed: ' + (e.message || e));
  }
}
	  

// ---------- Bluechip Actions ----------
// Enroll as Bluechip
async function enrollBluechip(){
    try {
      if(!contracts.staking){ 
        await attachContractsIfSet(); 
        if(!contracts.staking) return alert('Set staking contract'); 
      }
      if(typeof contracts.staking.enrollBluechip === 'function'){
        const tx = await contracts.staking.enrollBluechip();
        log('enrollBluechip tx', tx.hash);
        await tx.wait();
        log('enrollBluechip done');
      } else {
        alert('enrollBluechip not found in ABI');
      }
    } catch(e){ log('enrollBluechip err', e && e.message ? e.message : e); }
  }

// Harvest Bluechip
async function harvestBluechip(){
    try {
      const collection = document.getElementById('bluechipCollectionInput').value.trim();
      if(!collection) return alert('Enter a collection address');
      if(!contracts.staking){ 
        await attachContractsIfSet(); 
        if(!contracts.staking) return alert('Set staking contract'); 
      }
      if(typeof contracts.staking.harvestBluechip === 'function'){
        const tx = await contracts.staking.harvestBluechip(collection);
        log('harvestBluechip tx', tx.hash);
        await tx.wait();
        log('harvestBluechip done');
      } else {
        alert('harvestBluechip not found in ABI');
      }
    } catch(e){ log('harvestBluechip err', e && e.message ? e.message : e); }
  } 

// Refresh Bluechip Info
async function refreshBluechip(){
  try {
    if(!contracts.staking){ 
      await attachContractsIfSet(); 
      if(!contracts.staking) return alert('Set staking contract'); 
    }
    if(typeof contracts.staking.bluechipWallets === 'function'){
      const me = await signer.getAddress();

      const enrolled = await contracts.staking.bluechipWallets(
        ethers.constants.AddressZero,
        me
      );
      $('bluechipStatus').innerText = enrolled ? '‚úÖ Enrolled' : '‚ùå Not Enrolled';

      const lastBlock = await contracts.staking.bluechipLastHarvestBlock(
        ethers.constants.AddressZero,
        me
      );
      $('bluechipLastBlock').innerText =
        lastBlock.toString() !== '0' ? lastBlock.toString() : '‚Äî';

      const fee = await contracts.staking.bluechipWalletFee();
      $('bluechipFee').innerText = `${fee.toString()} CATA`;

      log('refreshBluechip done');
    } else {
      alert('bluechipWallets not found in ABI');
    }
  } catch(e){ log('refreshBluechip err', e && e.message ? e.message : e); }
}

	  
  // ---------- NFT approval ----------
  async function approveNFT(){
    try {
      const collection = $('nftCollection').value.trim();
      if(!collection) return alert('collection required');
      const stakingAddr = $('addrStaking').value.trim();
      if(!stakingAddr) return alert('staking address required');
      const nft = new ethers.Contract(collection, ERC721_ABI, signer);
      const me = await signer.getAddress();
      const already = await nft.isApprovedForAll(me, stakingAddr);
      if(already){ log('already approved'); return; }
      const tx = await nft.setApprovalForAll(stakingAddr, true);
      log('approve tx', tx.hash);
      await tx.wait();
      log('approve complete');
    } catch(e){ log('approveNFT err', e && e.message ? e.message : e); }
  }

  // ---------- Staking single ----------
  async function termStake(){
    try {
      if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
      const collection = $('nftCollection').value.trim();
      const tokenId = $('nftTokenId').value.trim();
      if(!collection || !tokenId) return alert('collection & tokenId required');
      const tx = await contracts.staking.termStake(collection, tokenId);
      log('termStake tx', tx.hash);
      await tx.wait();
      log('termStake done');
    } catch(e){ log('termStake err', e && e.message ? e.message : e); }
  }

  async function permanentStake(){
    try {
      if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
      const collection = $('nftCollection').value.trim();
      const tokenId = $('nftTokenId').value.trim();
      if(!collection || !tokenId) return alert('collection & tokenId required');
      const tx = await contracts.staking.permanentStake(collection, tokenId);
      log('permanentStake tx', tx.hash);
      await tx.wait();
      log('permanentStake done');
    } catch(e){ log('permanentStake err', e && e.message ? e.message : e); }
  }

  async function unstake(){
    try {
      if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
      const collection = $('nftCollection').value.trim();
      const tokenId = $('nftTokenId').value.trim();
      if(!collection || !tokenId) return alert('collection & tokenId required');
      const tx = await contracts.staking.unstake(collection, tokenId);
      log('unstake tx', tx.hash);
      await tx.wait();
      log('unstake done');
    } catch(e){ log('unstake err', e && e.message ? e.message : e); }
  }

  // harvest - contract may or may not expose public harvest; if exists call it, otherwise advise.
  async function harvest(){
    try {
      if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
      // try common signatures
      if(typeof contracts.staking.harvest === 'function'){
        const collection = $('nftCollection').value.trim();
        const tokenId = $('nftTokenId').value.trim();
        const tx = await contracts.staking.harvest(collection, tokenId);
        log('harvest tx', tx.hash);
        await tx.wait();
        log('harvest done');
        return;
      }
      alert('No public harvest function found in staking ABI ‚Äî rewards are minted on unstake or via contract-internal logic.');
    } catch(e){ log('harvest err', e && e.message ? e.message : e); }
  }

  // ---------- Batch helpers ----------
  function parseBatchPairs(){
    const raw = $('batchNFTs').value.trim();
    if(!raw) return [];
    const lines = raw.split('\n').map(l=>l.trim()).filter(l=>l.length>0);
    const pairs = [];
    for(const ln of lines){
      const parts = ln.split(',').map(p=>p.trim()).filter(p=>p.length>0);
      if(parts.length >= 2) pairs.push({collection: parts[0], tokenId: parts[1]});
    }
    return pairs;
  }

  async function batchTermStake(){
    try {
      const pairs = parseBatchPairs();
      if(pairs.length === 0) return alert('No pairs to stake');
      if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
      // prefer a batch function if present
      if(typeof contracts.staking.batchTermStake === 'function'){
        const cols = pairs.map(p=>p.collection);
        const ids = pairs.map(p=>p.tokenId);
        const tx = await contracts.staking.batchTermStake(cols, ids);
        log('batchTermStake tx', tx.hash);
        await tx.wait();
        log('batchTermStake done');
      } else {
        // fallback sequential
        for(const p of pairs){
          const tx = await contracts.staking.termStake(p.collection, p.tokenId);
          log('termStake seq tx', tx.hash);
          await tx.wait();
        }
        log('batchTermStake sequential done');
      }
    } catch(e){ log('batchTermStake err', e && e.message ? e.message : e); }
  }

  async function batchPermStake(){
    try {
      const pairs = parseBatchPairs();
      if(pairs.length === 0) return alert('No pairs to stake');
      if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
      if(typeof contracts.staking.batchPermanentStake === 'function'){
        const cols = pairs.map(p=>p.collection);
        const ids = pairs.map(p=>p.tokenId);
        const tx = await contracts.staking.batchPermanentStake(cols, ids);
        log('batchPermanentStake tx', tx.hash);
        await tx.wait();
        log('batchPermanentStake done');
      } else {
        for(const p of pairs){
          const tx = await contracts.staking.permanentStake(p.collection, p.tokenId);
          log('permanentStake seq tx', tx.hash);
          await tx.wait();
        }
        log('batchPermStake sequential done');
      }
    } catch(e){ log('batchPermStake err', e && e.message ? e.message : e); }
  }

  async function batchUnstake(){
    try {
      const pairs = parseBatchPairs();
      if(pairs.length === 0) return alert('No pairs to unstake');
      if(!contracts.staking) { await attachContractsIfSet(); if(!contracts.staking) return alert('Set staking contract'); }
      if(typeof contracts.staking.batchUnstake === 'function'){
        const cols = pairs.map(p=>p.collection);
        const ids = pairs.map(p=>p.tokenId);
        const tx = await contracts.staking.batchUnstake(cols, ids);
        log('batchUnstake tx', tx.hash);
        await tx.wait();
        log('batchUnstake done');
      } else {
        for(const p of pairs){
          const tx = await contracts.staking.unstake(p.collection, p.tokenId);
          log('unstake seq tx', tx.hash);
          await tx.wait();
        }
        log('batchUnstake sequential done');
      }
    } catch(e){ log('batchUnstake err', e && e.message ? e.message : e); }
  }

	  // Helper: parse textarea "collection,tokenId" lines into objects
function parseBatchHarvestPairs() {
  const txt = $('batchHarvestNFTs').value.trim();
  if (!txt) return [];
  return txt.split(/\r?\n/).map(line => {
    const parts = line.split(',').map(s => s.trim()).filter(Boolean);
    if (parts.length < 2) return null;
    const collection = parts[0];
    const tokenId = parts[1];
    if (!collection || !tokenId) return null;
    return { collection, tokenId };
  }).filter(Boolean);
}

// Check Pending Rewards
async function checkPendingRewards(){
  try {
    const collection = $('nftCollection').value.trim();
    const tokenId = parseInt($('nftTokenId').value.trim(), 10);
    if(!collection) return alert('Enter a collection address');
    if(isNaN(tokenId)) return alert('Enter a valid token ID');

    if(!contracts.staking){ 
      await attachContractsIfSet(); 
      if(!contracts.staking) return alert('Set staking contract'); 
    }

    if(typeof contracts.staking.pendingRewards === 'function'){
      const account = await getAccount();
      const rewards = await contracts.staking.pendingRewards(collection, account, tokenId);
      $('pendingRewardsResult').innerText = `${rewards.toString()} CATA`;
      log('checkPendingRewards done');
    } else {
      alert('pendingRewards not found in ABI');
    }
  } catch(e){ 
    log('checkPendingRewards err', e && e.message ? e.message : e); 
    alert(e.message || e);
  }
}

// Refresh Staking Stats
async function refreshStakingStats(){
  try {
    if(!contracts.staking){ 
      await attachContractsIfSet();
      if(!contracts.staking) return alert('Set staking contract');
    }

    if(typeof contracts.staking.totalStakedAll === 'function'){
      const [all, term, perm] = await Promise.all([
        contracts.staking.totalStakedAll(),
        contracts.staking.totalStakedTerm(),
        contracts.staking.totalStakedPerm()
      ]);

      $('stakedAll').innerText = all.toString();
      $('stakedTerm').innerText = term.toString();
      $('stakedPerm').innerText = perm.toString();

      log('refreshStakingStats done');
    } else {
      alert('staking stats functions not found in ABI');
    }
  } catch(e){ 
    log('refreshStakingStats err', e && e.message ? e.message : e); 
    alert(e.message || e);
  }
}

// View Portfolio
async function viewPortfolio(){
  try {
    const collection = $('nftCollection').value.trim();
    if(!collection) return alert('Enter a collection address');

    if(!contracts.staking){ 
      await attachContractsIfSet();
      if(!contracts.staking) return alert('Set staking contract');
    }

    if(typeof contracts.staking.stakePortfolioByUser === 'function'){
      const account = await getAccount();
      const portfolio = await contracts.staking.stakePortfolioByUser(collection, account);
      $('portfolioResult').innerText = portfolio.length > 0 
        ? portfolio.join(', ') 
        : 'No NFTs staked.';

      log('viewPortfolio done');
    } else {
      alert('stakePortfolioByUser not found in ABI');
    }
  } catch(e){ 
    log('viewPortfolio err', e && e.message ? e.message : e); 
    alert(e.message || e);
  }
}


// Group by collection => { '0xCollA': ['123','124'], '0xCollB': ['555'] }
function groupByCollection(pairs) {
  const map = {};
  for (const p of pairs) {
    const col = p.collection.toLowerCase();
    if (!map[col]) map[col] = [];
    // keep as string or BigInt depending on how you send; strings are fine for ethers
    map[col].push(p.tokenId.toString());
  }
  return map;
}

async function batchHarvest() {
  try {
    const pairs = parseBatchHarvestPairs();
    if (pairs.length === 0) {
      alert('No pairs to harvest');
      return;
    }

    // ensure contracts.staking exists (attach if needed)
    if (!contracts || !contracts.staking) {
      if (typeof attachContractsIfSet === 'function') {
        await attachContractsIfSet();
      }
      if (!contracts || !contracts.staking) {
        return alert('Staking contract not set. Set addresses and attach contracts first.');
      }
    }

    // Prefer calling harvestBatch(collection, uint256[] tokenIds)
    const byCollection = groupByCollection(pairs);

    // Detect if harvestBatch exists in ABI
    const hasHarvestBatch = typeof contracts.staking.harvestBatch === 'function';
    const hasHarvestSingle = typeof contracts.staking.harvest === 'function';

    if (!hasHarvestBatch && !hasHarvestSingle) {
      return alert('Contract ABI lacks harvestBatch and harvest functions.');
    }

    // Iterate groups
    for (const colLower of Object.keys(byCollection)) {
      const collection = colLower; // already lowercase; contract accepts checksummed address too
      const ids = byCollection[colLower];

      if (hasHarvestBatch) {
        // call harvestBatch(collection, uint256[] tokenIds)
        log('calling harvestBatch for', collection, 'ids:', ids);
        const tx = await contracts.staking.harvestBatch(collection, ids);
        log('harvestBatch tx', tx.hash);
        await tx.wait();
        log('harvestBatch confirmed for', collection);
      } else {
        // fallback: call harvest(collection, tokenId) for each id
        for (const id of ids) {
          log('calling harvest for', collection, id);
          const tx = await contracts.staking.harvest(collection, id);
          log('harvest tx', tx.hash);
          await tx.wait();
          log('harvest confirmed', id);
        }
      }
    }

    log('batchHarvest: done for all collections');
  } catch (err) {
    log('batchHarvest err', err && err.message ? err.message : err);
  }
}

    // ---------- Governance Section ----------
const PROPOSAL_MAPPING = {
  BASE_REWARD: 0,
  HARVEST_FEE: 1,
  UNSTAKE_FEE: 2,
  REGISTRATION_FEE_FALLBACK: 3,
  VOTING_PARAM: 4,
  TIER_UPGRADE: 5,
  COUNCIL_RESEED_ACTIVE: 6,
  COUNCIL_PROPOSE_STANDBY: 7,
  COUNCIL_COMMIT_STANDBY: 8,
  COUNCIL_ACTIVATE_STANDBY: 9,
  COUNCIL_PROPOSE_NEW_DAO: 10,
  COUNCIL_COMMIT_NEW_DAO: 11,
  COUNCIL_CLEAR_LOCK: 12,
  UPGRADE_COUNCIL: 13
};

// Toggle extra input fields when proposal type changes
$('proposalType').addEventListener('change', () => {
  const type = $('proposalType').value;
  $('tierUpgradeRow').classList.add('hidden');
  $('councilBatchRow').classList.add('hidden');
  $('newDaoRow').classList.add('hidden');
  $('upgradeCouncilRow').classList.add('hidden');

  if (type === 'TIER_UPGRADE') {
    $('tierUpgradeRow').classList.remove('hidden');
  } else if (type === 'COUNCIL_RESEED_ACTIVE' || type === 'COUNCIL_PROPOSE_STANDBY') {
    $('councilBatchRow').classList.remove('hidden');
  } else if (type === 'COUNCIL_PROPOSE_NEW_DAO') {
    $('newDaoRow').classList.remove('hidden');
  } else if (type === 'UPGRADE_COUNCIL') {
    $('upgradeCouncilRow').classList.remove('hidden');
  }
});

// Create Proposal
async function createProposal() {
  try {
    if (!contracts.governance) {
      await attachContractsIfSet();
      if (!contracts.governance) return alert('Governance not set');
    }

    const typeStr = $('proposalType').value;
    const pType = PROPOSAL_MAPPING[typeStr];

    let paramTarget = parseInt($('paramTarget').value || '0');
    let newValueRaw = $('proposalValue').value.trim() || '0';
    let newValue = ethers.BigNumber.from(newValueRaw);
    let ctx = $('proposalCollectionCtx').value.trim() || ethers.constants.AddressZero;

    if (typeStr === 'TIER_UPGRADE') {
      ctx = $('tierCollection').value.trim();
      paramTarget = parseInt($('tierTo').value);
      newValue = ethers.BigNumber.from($('tierDeclaredSupply').value || '0');
    } else if (typeStr === 'COUNCIL_RESEED_ACTIVE' || typeStr === 'COUNCIL_PROPOSE_STANDBY') {
      const addrs = Array.from(document.querySelectorAll('.councilAddr')).map(el => el.value.trim());
      if (addrs.length !== 7 || addrs.some(a => !a)) return alert('Must provide 7 guardian addresses');
      const payload = await contracts.governance.encodeCouncilBatch(addrs);
      ctx = payload;
      newValue = 0;
      paramTarget = 0;
    } else if (typeStr === 'COUNCIL_PROPOSE_NEW_DAO') {
      ctx = $('newDaoAddr').value.trim();
    } else if (typeStr === 'UPGRADE_COUNCIL') {
      ctx = $('newCouncilImpl').value.trim();
    }

    const tx = await contracts.governance.propose(pType, paramTarget, newValue, ctx);
    log('propose tx', tx.hash);
    await tx.wait();
    log('proposal created');
  } catch (e) {
    log('createProposal err', e.message || e);
  }
}

// Vote
async function voteProposal() {
  try {
    if (!contracts.governance) {
      await attachContractsIfSet();
      if (!contracts.governance) return alert('Governance not set');
    }
    const id = $('proposalId').value.trim();
    if (!id) return alert('Proposal ID required');
    const ctx = $('proposalCollectionCtx').value.trim() || ethers.constants.AddressZero;
    const tx = await contracts.governance.vote(id, ctx);
    log('vote tx', tx.hash);
    await tx.wait();
    log('voted');
  } catch (e) {
    log('voteProposal err', e.message || e);
  }
}

// Execute
async function execProposal() {
  try {
    if (!contracts.governance) {
      await attachContractsIfSet();
      if (!contracts.governance) return alert('Governance not set');
    }
    const id = $('proposalId').value.trim();
    if (!id) return alert('Proposal ID required');
    const tx = await contracts.governance.executeProposal(id);
    log('exec tx', tx.hash);
    await tx.wait();
    log('executed');
  } catch (e) {
    log('execProposal err', e.message || e);
  }
}

// Fetch Proposal Details
async function fetchProposal() {
  try {
    if (!contracts.governance) {
      await attachContractsIfSet();
      if (!contracts.governance) return alert('Governance not set');
    }
    const id = $('proposalId').value.trim();
    if (!id) return alert('Proposal ID required');
    let info = null;
    try { info = await contracts.governance.proposals(id); } catch (e) { /* ignore */ }
    try { if (!info) info = await contracts.governance.proposalPayloads(id); } catch (e) {}
    log('proposal fetch', info || 'no data');
  } catch (e) {
    log('fetchProposal err', e.message || e);
  }
}

// ---------- Proposal Explorer ----------
const proposalsMap = {};

function renderProposalsTable() {
  const tbody = $('proposalsTbody');
  tbody.innerHTML = '';
  Object.values(proposalsMap).forEach(p => {
    const tr = document.createElement('tr');
    tr.className = 'border-t border-slate-700';
    tr.innerHTML = `
      <td class="p-2 font-mono text-xs">${p.id}</td>
      <td class="p-2">${p.type}</td>
      <td class="p-2">${p.value}</td>
      <td class="p-2">${p.ctx}</td>
      <td class="p-2">${p.proposer || '-'}</td>
      <td class="p-2">${p.votes || 0}</td>
      <td class="p-2">${p.executed ? 'Yes' : 'No'}</td>
      <td class="p-2">
        <button class="p-1 bg-slate-600 rounded text-xs" onclick="$('proposalId').value='${p.id}'">Load</button>
      </td>`;
    tbody.appendChild(tr);
  });
}

// Governance Event Listeners
function startGovernanceListeners() {
  if (!contracts.governance) return;
  const g = contracts.governance;

  g.on("ProposalCreated", (id, proposer, pType) => {
    const pid = id.toString();
    proposalsMap[pid] = { id: pid, proposer, type: pType.toString(), value: '‚Äî', ctx: '‚Äî', votes: 0, executed: false };
    renderProposalsTable();
  });

  g.on("VoteCast", (voter, id, support, votes) => {
    const pid = id.toString();
    proposalsMap[pid] = proposalsMap[pid] || { id: pid };
    proposalsMap[pid].votes = (proposalsMap[pid].votes || 0) + parseInt(votes.toString());
    renderProposalsTable();
  });

  g.on("ProposalExecuted", (id) => {
    const pid = id.toString();
    proposalsMap[pid] = proposalsMap[pid] || { id: pid };
    proposalsMap[pid].executed = true;
    renderProposalsTable();
  });
}

// Start event listeners once contracts are attached + bind buttons
window.addEventListener('DOMContentLoaded', async () => {
  await attachContractsIfSet();
  startGovernanceListeners();
});
   
	  // Guardian Council contract functions
// ---------- DAO ----------
async function proposeDao(){
  try {
    if(!contracts.council) return alert("Council contract not attached");
    const newDao = $('newDaoAddr').value.trim();
    if(!newDao) return alert("Enter DAO address");
    const tx = await contracts.council.proposeNewDAO(newDao);
    log('propose DAO tx', tx.hash);
    await tx.wait();
    log('DAO proposal submitted');
    alert("‚úÖ DAO proposal submitted");
  } catch(e){
    log('proposeDao err', e && e.message ? e.message : e);
    alert(e.message || e);
  }
}

async function commitDao(){
  try {
    if(!contracts.council) return alert("Council contract not attached");
    const tx = await contracts.council.commitNewDAO();
    log('commit DAO tx', tx.hash);
    await tx.wait();
    log('DAO committed');
    alert("‚úÖ DAO committed");
  } catch(e){
    log('commitDao err', e && e.message ? e.message : e);
    alert(e.message || e);
  }
}

// Active Batch
async function proposeActiveBatch(){
  try {
    if(!contracts.council) return alert("Council contract not attached");
    const arr = parse7($('activeBatchInput').value);
    const tx = await contracts.council.daoProposeSeedActiveBatch(arr);
    log('propose active batch tx', tx.hash);
    await tx.wait();
    log('proposeActiveBatch done');
    alert("‚úÖ Active batch proposed");
  } catch(e){
    log('proposeActiveBatch err', e && e.message ? e.message : e);
    alert(e.message || e);
  }
}

async function commitActiveBatch(){
  try {
    if(!contracts.council) return alert("Council contract not attached");
    const tx = await contracts.council.daoCommitSeedActiveBatch();
    log('commit active batch tx', tx.hash);
    await tx.wait();
    log('commitActiveBatch done');
    alert("‚úÖ Active batch committed");
  } catch(e){
    log('commitActiveBatch err', e && e.message ? e.message : e);
    alert(e.message || e);
  }
}

// Standby Batch
async function proposeStandbyBatch(){
  try {
    if(!contracts.council) return alert("Council contract not attached");
    const arr = parse7($('standbyBatchInput').value);
    const tx = await contracts.council.daoProposeSeedStandbyBatch(arr);
    log('propose standby batch tx', tx.hash);
    await tx.wait();
    log('proposeStandbyBatch done');
    alert("‚úÖ Standby batch proposed");
  } catch(e){
    log('proposeStandbyBatch err', e && e.message ? e.message : e);
    alert(e.message || e);
  }
}

async function commitStandbyBatch(){
  try {
    if(!contracts.council) return alert("Council contract not attached");
    const tx = await contracts.council.daoCommitSeedStandbyBatch();
    log('commit standby batch tx', tx.hash);
    await tx.wait();
    log('commitStandbyBatch done');
    alert("‚úÖ Standby batch committed");
  } catch(e){
    log('commitStandbyBatch err', e && e.message ? e.message : e);
    alert(e.message || e);
  }
}

async function activateStandby(){
  try {
    if(!contracts.council) return alert("Council contract not attached");
    const tx = await contracts.council.daoActivateStandby();
    log('activate standby tx', tx.hash);
    await tx.wait();
    log('activateStandby done');
    alert("‚úÖ Standby batch activated");
  } catch(e){
    log('activateStandby err', e && e.message ? e.message : e);
    alert(e.message || e);
  }
}

// Lock
async function clearLock(){
  try {
    if(!contracts.council) return alert("Council contract not attached");
    const tx = await contracts.council.daoClearLockAndWarning();
    log('clear lock tx', tx.hash);
    await tx.wait();
    log('clearLock done');
    alert("‚úÖ Lock cleared");
  } catch(e){
    log('clearLock err', e && e.message ? e.message : e);
    alert(e.message || e);
  }
}

// Parse helper
function parse7(txt){
  const arr = txt.split('\n').map(s=>s.trim()).filter(Boolean);
  if(arr.length !== 7) throw new Error("Need exactly 7 addresses");
  return arr;
}
	  
// Recovery
async function proposeRecovery(){
  try {
    const kind = parseInt($('recoveryKind').value, 10);
    const proposed = $('recoveryProposed').value.trim();
    const callTarget = $('recoveryCallTarget').value.trim();
    const callData = $('recoveryCallData').value.trim();

    if(!proposed || !callTarget || !callData) {
      return alert("Fill all recovery fields");
    }

    const tx = await contracts.council.proposeRecovery(kind, proposed, callTarget, callData);
    log('proposeRecovery tx', tx.hash);
    await tx.wait();
    log('Recovery proposed');
    alert("Recovery proposal submitted!");
  } catch(e) {
    log('proposeRecovery err', e);
    alert(e.message || e);
  }
}

async function approveRecovery(){
  try {
    const kind = parseInt($('recoveryKind').value, 10);
    const tx = await contracts.council.approveRecovery(kind);
    log('approveRecovery tx', tx.hash);
    await tx.wait();
    log('Recovery approved');
    alert("Recovery approved!");
  } catch(e) {
    log('approveRecovery err', e);
    alert(e.message || e);
  }
}

async function executeRecovery(){
  try {
    const kind = parseInt($('recoveryKind').value, 10);
    const tx = await contracts.council.executeRecovery(kind);
    log('executeRecovery tx', tx.hash);
    await tx.wait();
    log('Recovery executed');
    alert("Recovery executed!");
  } catch(e) {
    log('executeRecovery err', e);
    alert(e.message || e);
  }
}

async function vetoRecovery(){
  try {
    const kind = parseInt($('recoveryKind').value, 10);
    const tx = await contracts.council.lastHonestHaltAndPromote(kind);
    log('vetoRecovery tx', tx.hash);
    await tx.wait();
    log('Recovery vetoed');
    alert("Recovery vetoed!");
  } catch(e) {
    log('vetoRecovery err', e);
    alert(e.message || e);
  }
}

	  async function refreshRecoveryInfo() {
  try {
    const kind = parseInt($('recoveryKind').value, 10);

    const [proposed, approvals, deadline, executed, callTarget, callData] =
      await contracts.council.getRecoveryState(kind);

    const [guardian, expiry] = await contracts.council.getTempVeto();

    $('riProposed').innerText = proposed;
    $('riApprovals').innerText = approvals;
    $('riDeadline').innerText = new Date(deadline * 1000).toLocaleString();
    $('riExecuted').innerText = executed ? "‚úÖ Yes" : "‚ùå No";
    $('riCallTarget').innerText = callTarget;
    $('riCallData').innerText = callData;
    $('riGuardian').innerText = guardian;
    $('riVetoExpiry').innerText = expiry > 0 ? new Date(expiry * 1000).toLocaleString() : "-";
  } catch (e) {
    alert("Error loading recovery info: " + (e.message || e));
  }
}


	  // Encode calldata helper
async function encodeCallData() {
  try {
    const fnSig = $('recoveryFunction').value.trim(); // e.g. "upgradeTo(address)"
    const args = $('recoveryArgs').value.trim().split(',').map(s => s.trim()).filter(Boolean);

    if (!fnSig) return alert("Enter function signature");
    
    // Create ethers.js Interface
    const iface = new ethers.utils.Interface([ "function " + fnSig ]);
    const fnName = fnSig.split('(')[0]; // extract name before '('

    const callData = iface.encodeFunctionData(fnName, args);
    $('recoveryCallData').value = callData;

    alert("‚úÖ CallData encoded!");
  } catch (e) {
    console.error(e);
    alert("Error encoding callData: " + (e.message || e));
  }
}

	  
  // ---------- Bind UI on load ----------
  window.addEventListener('load', async ()=>{
    loadSavedAddrs();
    await loadABIs(); // pre-load ABIs for faster attach later

    // Connect / disconnect
    $('connectBtn').onclick = connect;
    $('disconnectBtn').onclick = disconnect;

    // Save/load addresses
    $('saveAddrs').onclick = ()=>{
      const payload = {
        addrCata: $('addrCata').value.trim(),
        addrStaking: $('addrStaking').value.trim(),
        addrGovernance: $('addrGovernance').value.trim(),
        addrCouncil: $('addrCouncil').value.trim()
      };
      saveAddrsToLocal(payload);
      // try attach if already connected
      if(signer) attachContractsIfSet();
    };
    $('loadAddrs').onclick = ()=>{ loadSavedAddrs(); if(signer) attachContractsIfSet(); };
		
    // CATA
    $('cataMintBtn').onclick = cataMint;
    $('cataBurnBtn').onclick = cataBurn;
    $('swapAdminBtn').onclick = cataSwapAdmin;

	// Register Collection 
/** Wire handlers to new UI elements ‚Äî call this inside your window load / UI ready handler */
function wireRegistrationUIs() {
  // Existing
  $('calcRegFeeBtn').onclick = handleCalcRegFee;
  $('approveRegCataBtn').onclick = handleApproveForRegistration;
  $('registerCollectionBtn').onclick = handleRegisterCollection;
  $('adminSetConfigBtn').onclick = handleAdminSetCollectionConfig;

  // New admin actions (safe checks in case button missing in DOM)
  if ($('removeCollectionBtn')) $('removeCollectionBtn').onclick = handleRemoveCollection;
  if ($('forfeitEscrowBtn')) $('forfeitEscrowBtn').onclick = handleForfeitEscrow;
  if ($('setBluechipBtn')) $('setBluechipBtn').onclick = handleToggleBluechip;
}

// call this after your existing UI init (e.g., at end of window.load)
wireRegistrationUIs();

// ---------- Bluechip Binds ----------
$('enrollBluechipBtn').onclick = enrollBluechip;
$('harvestBluechipBtn').onclick = harvestBluechip;
$('refreshBluechipBtn').onclick = refreshBluechip;
	  
    // Staking single
    $('approveNFTBtn').onclick = approveNFT;
    $('termStakeBtn').onclick = termStake;
    $('permApproveFeeBtn').onclick = async ()=>{ // approve CATA tokens for fees if CATA ABI exists
      try {
        if(!contracts.cata) { await attachContractsIfSet(); if(!contracts.cata) return alert('Set CATA contract'); }
        const stakingAddr = $('addrStaking').value.trim();
        if(!stakingAddr) return alert('staking address required');
        const amt = ethers.constants.MaxUint256;
        const tx = await contracts.cata.approve(stakingAddr, amt);
        log('approve CATA tx', tx.hash);
        await tx.wait();
        log('approve CATA done');
      } catch(e){ log('permApproveFee err', e && e.message ? e.message : e); }
    };
    $('permStakeBtn').onclick = permanentStake;
    $('unstakeBtn').onclick = unstake;
    $('harvestBtn').onclick = harvest;

    // Batch
    $('batchTermStakeBtn').onclick = batchTermStake;
    $('batchPermStakeBtn').onclick = batchPermStake;
    $('batchUnstakeBtn').onclick = batchUnstake;
$('batchHarvestBtn').onclick = batchHarvest;

	  // Extra staking binds
$('pendingRewardsBtn').onclick = checkPendingRewards;
$('refreshStakingStatsBtn').onclick = refreshStakingStats;
$('viewPortfolioBtn').onclick = viewPortfolio;
	

    // Governance
  $('createProposalBtn').onclick = createProposal;
  $('voteProposalBtn').onclick = voteProposal;
  $('execProposalBtn').onclick = execProposal;
  $('fetchProposalBtn').onclick = fetchProposal;

	  // DRS Guardian Council 
// ---------- Bind Buttons ----------
$('proposeDaoBtn').onclick = proposeDao;
$('commitDaoBtn').onclick = commitDao;
$('proposeActiveBatchBtn').onclick = proposeActiveBatch;
$('commitActiveBatchBtn').onclick = commitActiveBatch;
$('proposeStandbyBatchBtn').onclick = proposeStandbyBatch;
$('commitStandbyBatchBtn').onclick = commitStandbyBatch;
$('activateStandbyBtn').onclick = activateStandby;
$('clearLockBtn').onclick = clearLock;

$('proposeRecoveryBtn').onclick = proposeRecovery;
$('approveRecoveryBtn').onclick = approveRecovery;
$('executeRecoveryBtn').onclick = executeRecovery;
$('vetoRecoveryBtn').onclick = vetoRecovery;
$('refreshRecoveryBtn').onclick = refreshRecoveryInfo;
  
$('encodeCallDataBtn').onclick = encodeCallData;
	  
    log('UI ready');
  });

	// Tab switching for top nav buttons
document.querySelectorAll('.tabbtn').forEach(btn => {
  btn.addEventListener('click', () => {
    const tab = btn.getAttribute('data-tab');

    // Toggle active button
    document.querySelectorAll('.tabbtn').forEach(b => b.classList.remove('tab-active'));
    btn.classList.add('tab-active');

    // Toggle tab content
    document.querySelectorAll('.tab-content').forEach(sec => sec.classList.add('hidden'));
    document.getElementById(tab).classList.remove('hidden');
  });
});

// Global function for internal links
function selectTab(tabId) {
  // Toggle active button
  document.querySelectorAll('.tabbtn').forEach(b => b.classList.remove('tab-active'));
  const btn = document.querySelector(`[data-tab="${tabId}"]`);
  if (btn) btn.classList.add('tab-active');

  // Toggle tab content
  document.querySelectorAll('.tab-content').forEach(sec => sec.classList.add('hidden'));
  const section = document.getElementById(tabId);
  if (section) section.classList.remove('hidden');
		}
	  
  </script>
</body>
</html>

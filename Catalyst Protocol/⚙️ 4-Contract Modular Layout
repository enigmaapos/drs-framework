---

⚙️ Final Upgradeable Layout — Catalyst Protocol


---

1. CATA.sol (ERC20Upgradeable)

Base: ERC20Upgradeable, AccessControlUpgradeable, UUPSUpgradeable.

Roles:

DEFAULT_ADMIN_ROLE → GuardianCouncil.

MINTER_ROLE → CatalystStaking (assigned by GuardianCouncil).


Cap: Hard recyclable global cap = 1B CATA (totalSupply() + mint ≤ cap).

Minting:

Only CatalystStaking can mint rewards (enforced by MINTER_ROLE).


Burning:

Any holder can burn().




---

2. CatalystStaking.sol (Core)

Base: AccessControlUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable, UUPSUpgradeable.

Core Logic:

Collection registration (Unverified / Verified / Bluechip).

Custodial NFT staking (term & permanent).

Reward computation (welcome bonus, harvest, ongoing rewards).

Bluechip staking (counts under permanent cap).

Burn tracking (for governance weight).


Caps:

GLOBAL_NFT_CAP = 1,000,000 NFTs total.

GLOBAL_NFT_TERM_CAP = 750,000 NFTs.

GLOBAL_NFT_PERM_CAP = 250,000 NFTs (includes bluechip).


Reward Minting:

Calls into CATA for minting, which enforces 1B global cap.


Events:

Emits stake, unstake, burn, reward harvest, and collection stats for Governance.


Controls:

GuardianCouncil can pause/resume staking via PausableUpgradeable.




---

3. CatalystGovernance.sol

Base: AccessControlUpgradeable, UUPSUpgradeable.

Core Logic:

Proposals (create, vote, execute).

Proposals:

BASE_REWARD, HARVEST_FEE, UNSTAKE_FEE, REGISTRATION_FEE_FALLBACK, VOTING_PARAM, TIER_UPGRADE, COUNCIL_RESEED.


Voting: Weighted votes wired to CatalystStaking (staking.votingWeight).

Voting weight = derived from staking stats (burnedBy, stakeAge, collection stakes).

Executes governance-approved changes by calling setter functions in CatalystStaking (e.g., reward rate, fees, collection tier upgrades).

Council as DAO: council is the BatchGuardianCouncil contract.

Council reseed: Governance can propose/approve/execute a reseed with address[7] batch → calls daoSeedActiveBatch() on council.

Zero address validation: Ensures batches are valid before storing/executing.

Proposal encoding/decoding helpers: encodeCouncilBatch, decodeCouncilBatch.

Events for all state changes.

ReentrancyGuard on execution.


Design:

Lightweight — no heavy computation.

Avoids 24KB contract size issue by offloading logic to CatalystStaking.




---

4. GuardianCouncil.sol (BatchGuardianCouncilUpgradeable)

Base: AccessControlUpgradeable, UUPSUpgradeable.

Structure:

Two guardian batches: active (7 guardians) and standby (7 guardians).

5-of-7 approvals required to execute a recovery/admin action.


Recovery Actions:

Council proposals include (target, callData).

Executes atomic calldata exactly as supplied (grant→revoke must be atomic).

Threshold behavior:

5 approvals: execute.

6 approvals: emit warning.

7 approvals: execute + rotate standby → active.



Controls:

Holds DEFAULT_ADMIN_ROLE for both CATA and CatalystStaking.

Manages upgrades across all contracts.

Can reassign MINTER_ROLE if CatalystStaking is redeployed.


Safety Note:

Always encode calldata with safe grant new → revoke old admin patterns atomically.

